# 전송층 프로토콜

내용이 많아서 파일을 분할했다.

## UDP(user datagram protocol)
사용자 데이터그램 프로토콜. 비연결형, 신뢰성 없는 프로토콜. 최소한의 오버헤드를 가진 간단한 프로토콜.

#### 형식
![image](https://user-images.githubusercontent.com/38284141/51681809-159efe00-2029-11e9-8dff-1eba93dc5922.png)
8바이트짜리 헤더는 고정된 크기다. 헤더의 처음 두 필드는 소스와 목적지 포트 번호를 정의한다. 세 번째 필드는 사용자 데이터그램의 전체 길이를 정의한다.<br> 마지막 필드는 검사합을 담는다.

#### 장점
짧은 요구와 응답이 전송되는 경우 UDP가 유용하다. 비연결 서비스이니 지연이 적다.
#### 단점
오류제어와 흐름제어가 없어서 대량의 데이터 전송에는 적합하지 않다. 

## TCP(Transmission Control Protocol)
전송 제어 프로토콜. 연결지향, GBN과 SR을 결합한 신뢰성 있는 프로토콜. 현재 인터넷에서 가장 많이 사용하는 프로토콜.<br>
#### 스트림 전송 서비스
TCP는 스트림 지향 프로토콜이다. 데이터를 전송할 때 송신측과 수신측의 프로세스가 마치 가상의 튜브에 의해 연결되는 것처럼 만든다. 
![image](https://user-images.githubusercontent.com/38284141/51687107-26557100-2035-11e9-888c-7083a22d0121.png)
#### 송신 및 수신 버퍼
송신 및 수신 프로세스가 같은 속도로 데이터를 처리할 수 없기 때문에 임시저장을 위한 버퍼가 필요하다.<br>
![image](https://user-images.githubusercontent.com/38284141/51687166-569d0f80-2035-11e9-857e-f542b0bdd0c0.png)
버퍼들은 수백 또는 수천 바이트를 가질 수 있다. 그림에서는 버퍼 크기를 동일하게 맞췄다. <br>
흰색 부분은 앞으로 채워질 수 있는 비어있는 공간이고, 파란색 영역은 송신은 됐지만 확인 응답을 받지 못한 바이트들이다. 파란색 영역은 버퍼에는 올라왔지만 아직 보내지 않은 바이트. 수신측의 파란색 부분은 받았지만 처리가 안 된 상태다.<br>
#### 세그먼트
TCP는 세그먼트라고 부르는 패킷으로 다수의 바이트를 묶어서 그룹화한다. 세그먼트의 각 크기는 다를 수 있다.
![image](https://user-images.githubusercontent.com/38284141/51689242-9d8d0400-2039-11e9-8a8d-ad74bf0a40a2.png)
<br>
![image](https://user-images.githubusercontent.com/38284141/51690172-82bb8f00-203b-11e9-8009-e29408ca0e58.png)
세그먼트는 헤더와 데이터로 구성된다. 헤더는 기본 20바이트에서 최대 60바이트다.<br>
헤더에는 필드가 여러 개 존재한다. HLEN은 헤더길이, 6개 제어필드가 있는 control 필드, 상대가 유지해야 하는 윈도우의 바이트 단위 크기, 긴급 데이터를 포함한 세그먼트를 위한 긴급 포인터 필드 등이 있다.<br>
### 연결
TCP 연결(three-way handshaking)<br>
세방향 핸드셰이킹이라고 하는데 TCP의 연결 설정 방법이다.<br>
1번 단계에서 클라이언트는 SYN플래그만 설정된 SYN세그먼트를 보낸다. 이건 데이터가 없지만 순서번호는 1개 사용한다.<br>
2번째는 이걸 받은 서버가 SYN과 ACK이 설정된 세그먼트를 클라에게 보낸다. SYN플래그의 목적은 클라와 동일하게 통신을 위함이고, ACK은 클라가 보낸 세그먼트에 대한 수신응답으로 다음에 클라가 보내야 할 순서번호를 알린다. 이때 수신윈도의 크기인 rwnd값도 함께 보낸다. 마찬가지로 순서번호 1개를 사용한다.<br>
3번째 단계에서 서버가 보낸 SYN에 대한 응답으로 클라가 ACK을 보낸다. 데이터는 함께 갈 수도 있고 안 갈 수도 있는데 같이 가면 순서번호를 그 바이트만큼 사용한다.<br>
![image](https://user-images.githubusercontent.com/38284141/51702787-02efed80-2058-11e9-8cd7-8aacd4382893.png)


#### SYN 플러딩(flooding) 공격
해커가 근원지 IP를 조작해서 서로 다른 클라이언트에게 SYN 세그먼트가 들어오는 것처럼 가장하는 공격이다.<br>
짧은 시간에 대량의 세그먼트를 받은 서버는 자원이 고갈되어 마비될 수 있다.<br>
이 공격을 방어하기 위해 특정 시간 동안 들어오는 연결 요청 수에 제한을 두거나, 쿠키(cookie)를 사용해서 전체 연결 전까지 자원할당을 연기하는 방법을 사용한다.<br>

#### 데이터 밀어넣기(pushing data)
푸쉬 비트(PSH)라는 게 있다. 대화형 통신을 할 때 데이터의 지연 없이 최대한 빠른 응답을 원하는 경우에 사용한다. 송신측 프로세스가 푸쉬 동작을 요청하면 송신측 TCP는 윈도우가 채워지기를 기다리지 않고 즉시 전송한다. 그리고 푸쉬 비트를 설정해서 수신측 TCP에게 이 세그먼트가 최대한 빨리 응답하기를 바라는 데이터를 담고 있으니까, 수신측 윈도우가 채워지는 걸 기다리지 말고 수신측 프로세스에게 전달하라고 알린다.<br>
![image](https://user-images.githubusercontent.com/38284141/51705015-cde69980-205d-11e9-9329-6731ef4678ea.png)

그림에서 클라이언트는 푸쉬 비트를 설정해서 서버측 TCP가 윈도우 용량에 상관없이 프로세스로 전달하게 했다. 하지만 응답에서는 푸쉬 비트가 설정되지 않았다. 이처럼 TCP가 푸쉬 동작을 사용할지 말지 선택할 수 있다.
#### 긴급 데이터(urgent data)
만약 프로세스가 긴급히 데이터를 보내야 하는 경우에, URG비트를 설정한 세그먼트를 보내면 된다. 송신 TCP는 세그먼트 시작부분에 긴급 데이터를 삽입한다.
나머지 세그먼트에는 정상적 데이터가 들어갈 수 있다. 위에 헤더 형식에 있는 긴급지시자 필드에 긴급 데이터의 종료 지점과 정상 데이터의 시작 지점이 정의된다. <br>
만약 세그먼트 순서 번호가 15000이고 긴급 포인터 값이 200이면 긴급 데이터의 첫번째 바이트는 15000이고 마지막 바이트는 15200이다. 나머지는 긴급하지 않다. 수신 TCP는 프로세스에게 순서대로 데이터를 전달하고 어디까지가 긴급데이터인지 알려준다. 그 처리는 수신 프로세스에게 달려있다.<br>

#### 연결 종료
연결 종료시에도 세방향 핸드셰이킹을 사용한다.<br>
1단계로 클라이언트 프로세스로부터 종료 명령을 받은 클라이언트 TCP가 FIN 플래그가 설정된 FIN 세그먼트를 전송한다. 이 세그먼트에는 마지막 데이터가 포함될 수도 있고 단순 제어 세그먼트일 수도 있다.<br>
2단계로 서버가 마찬가지로 연결 종료를 알리기 위한 FIN플래그와 클라의 FIN 세그먼트에 대한 응답인 ACK플래그를 전송한다. 이 때도 마지막 데이터가 포함 될 수 있다.<br>
3단계로 클라이언트 TCP는 서버의 FIN 세그먼트에 대한 응답으로 ACK 세그먼트를 전송한다. 이 세그먼트는 데이터도 없고 순서번호도 없다.
![image](https://user-images.githubusercontent.com/38284141/51705770-d8099780-205f-11e9-9913-777f300659df.png)
<br>
Half-close 경우도 있는데 한쪽만 연결 종료를 하고 다른 쪽은 계속 데이터를 보내는 경우다. 이때 종료한 측은 확인응답만 한다.

#### 흐름제어
![image](https://user-images.githubusercontent.com/38284141/51707789-73513b80-2065-11e9-8bc5-bfcb442319df.png)
흐름제어는 그림과 같이 일어난다.

#### Silly Window Syndrome
흐름제어와 이어지는 내용인데, 송신측과 수신측에서 발생하는 각각의 경우가 있다.<br>
먼저 송신측에서 발생하는 경우는, 보낼 바이트가 1바이트인데 헤더로 40바이트가 붙는다면 네트워크 용량은 매우 비효율적으로 사용되는 것이다.<br>
이런 문제를 해결하려면 충분한 데이터가 버퍼에 쌓이도록 TCP가 기다리면 된다. 하지만 너무 오래 기다리면 지연이 문제가 된다. 그래서 네이글(Nagle's) 알고리즘을 사용한다.<br>
이 알고리즘은 1바이트라도 일단 첫 데이터는 전송한다. 그리고 그 세그먼트에 대한 응답을 받거나 세그먼트의 최대치만큼 데이터가 쌓일 동안 기다린다. 두 경우 중에 하나가 발생하면 세그먼트를 전송한다. 이렇게 하면 프로세스의 처리 속도와 네트워크 전달 속도를 모두 고려할 수 있게 된다.<br>
<br>
두번째로 수신측에서 발생하는 경우다. 이건 수신 프로세스가 데이터 처리 속도가 너무 느려서 버퍼가 넘쳐버리는 경우에 발생한다. 해결법은 두 가지가 있는데 클라크(Clark's solution) 방법은 수신 버퍼에 최대 크기 세그먼트를 수용할 만한 공간이 있거나, 버퍼가 반 이상 비어있기 전까지 송신측에 윈도 크기를 0으로 통보한다. 이러면 송신측의 윈도우가 실제로 0이 되진 않고 그냥 데이터 전송없이 기다린다. <br>
두 번째 방법은 ack을 늦게 보내는 것이다. 수신 버퍼에 충분한 공간이 있을 때까지 ack를 안보내면 송신측은 자연히 데이터를 보낼 수가 없게 된다. 이 지연은 0.5초 이상 이어질 수 없다.<br>

#### 오류제어
TCP에서 오류를 제어하는 방법에는 세그먼트에 검사합 필드를 붙여서 오류가 있으면 손실로 간주하는 것, 수신 확인을 위한 ACK를 보내는 것, 그리고 재전송이 있다.<br>
ACK에는 누적 확인응답인 ACK과 Selective ACK이 있다. SACK은 순서가 틀린 데이터블록과 중복 세그먼트 블록을 알려준다. SACK은 TCP헤더 끝에 옵션 형태로 구현된다.<br>
재전송에는 RTO(Retransmission time out)를 쓰는데 이건 왕복시간을 기반으로 설정된다. 이 시간 동안 ACK이 없으면 재전송한다. <br>
빠른 재전송이라는 건 동일한 ACK이 세 번 들어오면 RTO에 상관없이 즉시 재전송하는 것이다.

#### 혼잡제어
Cwnd: congestion window<br>
cwnd는 중간 네트워크의 혼잡을 의미하고 rwnd는 종단 네트워크의 혼잡을 의미한다. 그래서 실제 윈도우의 크기는 두 윈도우 중에서 더 작은 윈도우로 결정한다. <br>
![image](https://user-images.githubusercontent.com/38284141/51709819-c4aff980-206a-11e9-9055-93d2e0094b25.png)
위 그림은 Slow start 알고리즘인데 처음에 윈도우 크기를 1부터 시작해서 느린 시작이라는 이름이 붙었다. 하지만 ack을 받을 때 마다 지수적으로 윈도우 크기가 증가하므로 빠르게 커진다. <br>
![image](https://user-images.githubusercontent.com/38284141/51709980-3425e900-206b-11e9-9760-2adba918354f.png)
지수증가 도중 혼잡이 감지되거나 임계치에 도달하면 다음단계인 가산 증가가 시작된다. 여기선 윈도우가 1씩 증가하면서 혼잡을 관찰한다. 

## SCTP(Stream Control Transmission Protocol)
멀티미디어 통신을 위해 UDP와 TCP의 장점을 결합한 프로토콜. 
