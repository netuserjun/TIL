# DLC 서비스

데이터링크층은 2개의 부계층으로 나눌 수 있다. DLC와 MAC이다. 여기서는 DLC에 대해 다룬다.<br>
DLC는 데이터 링크 제어로, 두 인접한 노드 사이의 통신을 링크 종류에 관계없이 다룬다.<br>
데이터링크제어의 기능은 프레임짜기, 흐름제어, 오류제어 이다.<br>

# 프레임짜기
간단히 말하면 소포 포장이다. 프레임이라는 박스안에 비트들과 송신자와 수신자의 주소를 넣는 과정이다.<br>
프레임에 모든 비트를 한 번에 넣을 수도 있지만 이는 비효율적이다. 전송과정에서 비트 하나만 오류가 생겨도 전체를 다시 보내야 하기 때문이다. 또한 흐름제어와 오류제어에 있어서도 비효율적이다. 따라서 여러 개의 작은 프레임으로 나눈다.<br><br>

프레임은 일정한 크기를 가질 수도 있고, 가변적일 수도 있다. 가변적인 경우는 LAN에서 주로 쓰는데 프레임들이 링크를 통과할때 프레임의 시작지점과 끝지점을 정의해 주어야한다. 이 가변적인 방법에는 문자 중심 방법과 비트 중심 방법이 있다.<br><br>

# 문자중심 프레임짜기(character-oriented framing)
문자 중심 프레임 짜기에서 전달되는 데이터는 ASKII같은 코딩 시스템의 8비트 문자다. 발신지주소와 목적지주소를 담은 헤더, 오류검출과 정정을 위한 중복비트가 담긴 트레일러 역시 8비트의 정수배로 구성된다. 프레임 사이를 분리하기 위해 8비트 플래그(flag)가 프레임의 시작지점과 마지막에 추가된다. 이 플래그는 프로토콜에 의해 특별한 문자로 구성된다. <br>
하지만 이 방식은 예전에 데이터링크층에서 문자열들만 교환하던 시기에만 좋았다. 그땐 지금처럼 오디오,비디오 같은 데이터가 없었으니 문자열에서 쓰이지 않는 임의의 문자를 플래그로 쓰면 됐던 것이다. 하지만 지금 이 방식을 그대로 쓰면 플래그와 실제 정보가 같아서 플래그가 나오기 전에 정보를 프레임의 마지막으로 오해될 수 있다.<br>
이 문제를 해결하기 위해 바이트 채우기(byte stuffing)라는 방법을 추가로 도입했다. 이 방식에서 만약 데이터 내부에 플래그와 동일한 패턴의 데이터가 생기면 특별한 바이트를 더해 넣는다. 즉 플래그와 똑같은 데이터 부위에 미리 정해진 추가 바이트가 채워진다. 이 추가 바이트를 ESC(escape character,탈출문자)라고 부른다. 수신측에서 이 ESC를 보게 되면 ESC를 제거하고 그 뒤에 나오는 데이터를 플래그가 아닌 데이터로 취급하게 된다.<br>
그런데! ESC가 문자열의 일부라면? <br>
이 문제는 ESC를 앞에 또 추가한다. 즉 2개의 ESC를 통해 '두번째 ESC는 ESC가 아니고 문자열의 일부입니다'라고 알려줘야한다.<br><br>

![image](https://user-images.githubusercontent.com/38284141/50897946-fc0a8d80-1450-11e9-8fda-632fd9b67a8e.png)
<br>
하지만 그래도 구식은 구식이다. 현대에 유니코드가 16비트나 32비트 워드를 사용하기 때문에 8비트 문자와는 상충한다. 따라서 역사속으로 사라지는 추세다.ㅃㅃ<br>

# 비트 중심 프로토콜

이 방식에서 프레임의 데이터부위는 전부 데이터를 나타내는 비트열이다. 그래도 헤더와 트레일러를 구분하는 경계와 각 프레임 사이를 구분하는 경계는 필요하다. 이 방식도 문자중심프레임짜기 처럼 대체로 01111110이라는 8비트 패턴의 플래그를 두어 경계로 삼고 있다. <br>
하지만 동일한 문제가 생긴다. 플래그의 내용이 데이터 안에 나타나는 경우다. <br>
이럴 때는 1개의 단일 비트를 채워 넣어서 그 패턴이 플래그가 아닌것처럼 보이게 한다. 이 방식은 비트채우기(bit stuffing)이라고 부른다. 위에 문자중심은 바이트 채우기였다. 혼동하지 말자.<br>
비트 채우기에서는 0 뒤에 1이 연속으로 5개가 온다면 추가로 0을 더해 넣는다. 이 추가된 비트는 수신자 측에서 제거된다.<br>
그러니까 01111110이 데이터에서 보이면 011111010으로 바뀐다는 것이다.<br>
진짜 플래그 01111110은 이렇게 0이 추가되지 않는다.<br>
근데 011111010이 원래 데이터인 경우에는 수신자에서 어떻게 처리하지?<br>
이 경우에도 0111110010으로 바꿔버린다.<br>
![image](https://user-images.githubusercontent.com/38284141/50898140-8f43c300-1451-11e9-9908-d3efc28a3ee1.png)

# 흐름제어

프레임이 전송될 때 너무 빠르게 전송되면 수신측에서는 수용용량을 넘는 프레임들을 폐기해야만 한다. 반대로 너무 느리게 전송되면 수신측은 아무것도 못하고 기다려야만 하므로 시스템이 비효율적이 된다. 흐름제어는 이 문제들 중에서 너무 빨리 전송되는 경우와 관련있다.<br>
여기서는 네트워크 층과 데이터링크 층 사이의 관계는 생각하지 않고 오직 두 데이터링크 층 사이에만 포커스를 맞춘다.<br><br>

송신측과 수신측은 패킷을 저장할 수 있는 메모리의 집합을 가지고 있다. 이걸 버퍼라고 부른다. 흐름제어 통신은 받는측에서 보내는측으로 신호를 보내면 발생한다. 수신 데이터링크층의 버퍼가 가득 차 있을 때 송신 데이터링크 층이 전달을 멈추거나 늦추라고 알리는 것이다.<br>

# 오류제어

네트워크층으로 손상된 패킷이 올라가는 것을 막기 위해 데이터링크층에서 오류제어 기능을 가져야한다.<br>
데이터링크층에서 다루는 오류제어는 아주 간단하다. 두 가지 방법이 있는데 <br>
첫 번째는 프레임이 손상되면 프레임을 폐기하고, 손상되지 않은 프레임은 네트워크층으로 전달된다. 이더넷, 유선LAN에서 쓰는 방식이다.<br>
두 번째는 프레임이 손상되면 프레임을 폐기하고, 손상되지 않았다면 확인응답(ACK)을 송신측에 전달한다.<br><br>

# 비연결지향과 연결지향 프로토콜

DLC 프로토콜은 비연결지향 혹은 연결지향 프로토콜이다.<br><br>

먼저 비연결지향 프로토콜은 프레임 사이에 연결이 없다는 것을 의미한다. 각 프레임들이 모두 독립적이라는 말이다. 프레임들은 번호도 매겨지지 않고 순서도 없다. 대부분의 LAN이 이 방식이다.<br><br>

연결지향 프로토콜은 1. 설정단계 2. 전송단계 3. 해제단계 의 순서로 이루어진다.<br>
서킷네트워크와 똑같은데 그렇다고 모든 연결지향 프로토콜이 서킷네트워크는 아니다.<br>
설정단계에서 두 노드사이의 논리적인 연결이 생기고, 전송단계에서 서로 관련된 프레임이 전송된 후, 해제단계에서 논리적인 연결이 종료된다.<br>
이 프로토콜에서 프레임들은 번호가 매겨지고 순서가 있다. 그래서 순서대로 수신되지 않으면, 수신자는 동일한 집합에 속하는 모든 프레임이 수신된 이후 네트워크층에 순서대로 제공될 때까지 기다려야 한다.(?) 순서대로 걍 탁탁 보내면 되지않나. 굳이 다 오기를 기다려야하는 이유가..?<br><br>


# 데이터링크층 프로토콜

데이터링크층에는 오류제어와 흐름제어를 위해 (단순, 정지/대기, Go-Back-N, 선택적반복) 이 네 가지 프로토콜이 있었지만, 뒤에 두 개는 사라졌다.<br>
나중에 전송층에서 네 가지 모두를 자세하게 다루니 우선은 처음 두 가지만 살펴본다.<br>

단순 프로토콜에서 수신자는 어떤 프레임을 수신했을 때 즉시 처리한다. 즉 수신자는 유입되는 프레임에 의해 절대 넘치지 않는다. 송신자는 수신자에게 그냥 생각없이 계속 보내는 것이다.<br><br>

정지/대기 프로토콜은 흐름제어와 오류제어를 사용한다. 송신자는 프레임을 보낸 후 똑같은 프레임 사본을 들고 시간을 재기 시작한다. 수신자는 프레임을 받고 검사해서 손상여부를 확인한다. 손상된 프레임은 그냥 버리고 정상적인 프레임이라면 송신자에게 ACK를 보낸다. 송신자는 일정 시간동안 ACK응답이 없으면 갖고 있던 복사본 프레임을 재전송하고, ACK이 오면 복사본을 폐기하고 다음 프레임을 보낸다.<br><br>



# HDLC(High-level DLC)

하이레벨 데이터링크제어는 비트지향 프로토콜이다. 당연히 점대점, 다중점 링크 모두에서 쓰인다.<br>
HDLC에는 두 가지 전송모드가 존재한다. 정규응답모드(NRM, normal response mode)와 비동기균형모드(ABM, asynchromous balanced mode)이다.<br>

NRM은 지국 구성이 비균형적이다. 그러니까 주국(primary station)이 하나 있고, 종국(secondary station)이 여러 개 있다. 주국은 명령을 보낼 수 있고, 종국은 단지 응답만 할 수 있다. 점대점과 다중점링크 모두에서 사용한다. 흔한 master-slave 관계네.<br>

ABM은 균형적이다. 점대점에서만 사용하고 연결된 두 지국은 서로 주고 받기가 가능하다. 그러니까 주국이자 종국이다. 보통 사용하는 모드다.<br>

## HDLC의 프레임
HDLC에는 프레임이 세 종류가 있다. 정보프레임, 감시프레임, 무번호프레임이다. 그러니까 데이터를 담을 박스가 세가지 종류인 것이다.<br>
이 프레임들은 필드라는 걸 6개까지 가질 수 있다. 필드는 프레임 그림을 보면 뭔지 이해하기 쉽다. 말 그대로 영역이다.<br>
### 플래그 필드
01111110 패턴을 갖는 시작 플래그 필드와 종료 플래그 필드. 프레임의 시작과 끝을 알린다.<br>
### 주소 필드
종국의 주소를 가지고 있는 필드. 주국이 만든 프레임에는 목적지의 주소가 담기고, 종국이 만든 프레임에는 발신지의 주소가 담긴다.<br>
네트워크의 필요에 따라서 1바이트 혹은 몇 바이트의 길이를 가진다.<br>
### 제어 필드
흐름제어와 오류제어에 사용되는 1바이트 혹은 2바이트짜리 필드.<br>
### 정보 필드 
네트워크층의 사용자 데이터를 포함하거나 관리정보를 포함한다. 네트워크마다 필드 길이가 다를 수 있다.<br>
### 프레임 검사 순서값(FCS) 필드
HDLC의 오류 검출 필드. 2바이트나 4바이트 짜리 CRC(순환중복검사)를 포함한다.<br>
<hr/>

## 정보프레임에서의 제어 필드
Information frame, 줄여서 I-frame은 네트워크층으로부터 사용자 데이터를 나르기 위해 설계됐다. 추가로 오류제어정보와 흐름제어정보도 포함할 수 있다.
<br>
제어 필드의 첫번째비트가 0이라는 말은 이 프레임이 i 프레임이라는 말이다.<br>
그 다음 3개 비트는 N(S)라고 불리는데, 프레임의 순서 번호를 나타낸다. 비트가 3개니까 0번부터 7번까지 매길수있다.<br>
그 뒤에 나오는 1개 비트는 P/F 비트인데, 1로 설정됐을 때만 의미가 있다. <br>
주국에서 종국으로 보낼 때 1이라면 Poll을 뜻하고, 종국에서 주국으로 보낼 때는 Final을 의미한다.<br>
마지막 3개 비트는 N(R)로 불린다. 피기배킹할 때 ACK번호에 해당한다. 여기서 피기배킹은 ACK를 데이터와 함께 보내는 거다.<br>

![image](https://user-images.githubusercontent.com/38284141/50899944-f021ca00-1456-11e9-9a45-0f8b4df9ab75.png)
 
## 감시프레임에서의 제어 필드
Supervisory farme, 줄어서 S-프레임은 피기배킹이 불가능하거나 부적절할 때 흐름제어와 오류제어를 위해 사용된다.<br>
이 S-프레임에는 정보 필드가 없다. <br>
제어 필드의 첫 2비트가 10이면 이 프레임이 감시프레임이라는 말이다.<br>
N(R)로 불리는 마지막 3개 비트는 이 감시프레임의 네 가지 유형에 따라서 ACK이거나 NAK에 해당한다.<br>
부호(code)라고 불리는 2개 비트로 이 유형을 정의한다.
![image](https://user-images.githubusercontent.com/38284141/50900121-8229d280-1457-11e9-8dde-d1d4e28a4241.png)

### 수신준비(Receive Ready,RR)
코드 부필드의 값이 00이면, 이는 RR S-프레임이다. 이 종류의 프레임은 정상 프레임들에 대해 확인응답을 한다. 여기서 코드 부필드란 위에서 말한 2개 비트를 말하는 거 같다.<br>
이 경우에 N(R)필드의 값은 확인응답 번호를 정의한다.
### 수신불가(Receive Not Ready,RNR)
코드 부필드의 값이 10이면, 이는 RNR S-프레임이다. 이 종류의 프레임은 RR프레임에 혼잡 제어 기능이 합해진 것이다. 그러니까 정상프레임에 확인응답도 하고, 송신자에게 송신 속도를 늦추도록 하기도 한다.<br>
N(R)은 확인응답번호이다.<br>
### 거부(REJ, reject)
코드 부필드가 01인 경우. GO-Back-N ARQ에서 사용되어 송신자의 타이머가 끝나기전에 프레임이 손실을 알려서 처리효율을 높이는 데 쓰인다.<br>
N(R)은 NAK번호이다.
### 선택적 거부(selective reject,SREJ)
코드 부필드가 11, 선택적 거부 ARQ의 NAK이다. HDLC프로토콜에서는 선택적 반복 대신 선택적거부라는 말을 쓴다.<br>
N(R)은 NAK번호이다.

## 무번호프레임에서의 제어 필드
Unnumbered frame, U-프레임은 서로 연결된 장치들 간에 세션관리와 제어정보를 교환하는 용도로 사용된다.<br>
S-프레임과 달리 U-프레임은 정보 필드를 가지고 있지만, 이 정보 필드는 사용자 데이터가 아니라 시스템 관리정보를 위해 사용된다.<br>
U-프레임도 제어 필드에 들어있는 비트들로 유형이 나뉜다.<br>
P/F비트 기준으로 앞 2개 비트와 뒤 3개 비트, 총 5개 비트를 통해 U-프레임 32가지가 만들어진다.<br>
![image](https://user-images.githubusercontent.com/38284141/50900148-95d53900-1457-11e9-87ed-ef1fbefaeecd.png)

# 점대점 프로토콜(PPP)
점대점연결을 위해 가장 많이 쓰이는 프로토콜. 장치들 사이에서 교환될 프레임의 형식을 정의하고, 링크를 어떻게 설정하고, 어떻게 데이터를 교환하는지 정의한다. 간단한 오류제어(손상프레임 폐기)는 제공하지만 흐름제어는 제공하지 않는다.<br>

## 다중화
PPP가 데이터링크층 프로토콜이지만 기능이 많기때문에 PPP가 사용하는 3종류의 프로토콜이 있다.<br>
링크 제어 프로토콜, 인증 프로토콜, 네트워크 제어 프로토콜  3가지다.<br>

### 링크 제어 프로토콜
링크의 설정,유지,형성,해제를 담당한다. 한 두 단말 간의 선택사항들을 결정하기 위한 협상 기능도 제공한다.
### 인증 프로토콜
사용자의 신원을 증명하는 인증 단계에서 쓰는 프로토콜로 두 가지가 있다. <br>
패스워드를 보내는 간단한 인증프로토콜(PAP)과 PAP보다 높은 보안성을 가진 CHAP(challenge handshake authentication protocol)이다.
### 네트워크 제어 프로토콜
IP패킷을 위해 네트워크층 연결을 설정,종료하는 패킷들의 집합을 IPCP(Internetwork Protocol control protocol)이라고 한다.<br>



