# DLC 서비스

데이터링크층은 2개의 부계층으로 나눌 수 있다. DLC와 MAC이다. 여기서는 DLC에 대해 다룬다.<br>
DLC는 데이터 링크 제어로, 두 인접한 노드 사이의 통신을 링크 종류에 관계없이 다룬다.<br>
데이터링크제어의 기능은 프레임짜기, 흐름제어, 오류제어 이다.<br>

# 프레임짜기
간단히 말하면 소포 포장이다. 프레임이라는 박스안에 비트들과 송신자와 수신자의 주소를 넣는 과정이다.<br>
프레임에 모든 비트를 한 번에 넣을 수도 있지만 이는 비효율적이다. 전송과정에서 비트 하나만 오류가 생겨도 전체를 다시 보내야 하기 때문이다. 또한 흐름제어와 오류제어에 있어서도 비효율적이다. 따라서 여러 개의 작은 프레임으로 나눈다.<br><br>

프레임은 일정한 크기를 가질 수도 있고, 가변적일 수도 있다. 가변적인 경우는 LAN에서 주로 쓰는데 프레임들이 링크를 통과할때 프레임의 시작지점과 끝지점을 정의해 주어야한다. 이 정의 방법에는 문자 중심 방법과 비트 중심 방법이 있다.<br><br>

# 문자중심 프레임짜기(character-oriented framing)
문자 중심 프레임 짜기에서 전달되는 데이터는 ASKII같은 코딩 시스템의 8비트 문자다. 발신지주소와 목적지주소를 담은 헤더, 오류검출과 정정을 위한 중복비트가 담긴 트레일러 역시 8비트의 정수배로 구성된다. 프레임 사이를 분리하기 위해 8비트 플래그(flag)가 프레임의 시작지점과 마지막에 추가된다. 이 플래그는 프로토콜에 의해 특별한 문자로 구성된다. <br>
하지만 이 방식은 예전에 데이터링크층에서 문자열들만 교환하던 시기에만 좋았다. 그땐 지금처럼 오디오,비디오 같은 데이터가 없었으니 문자열에서 쓰이지 않는 임의의 문자를 플래그로 쓰면 됐던 것이다. 하지만 지금 이 방식을 그대로 쓰면 플래그와 실제 정보가 같아서 플래그가 나오기 전에 정보를 프레임의 마지막으로 오해될 수 있다.<br>
이 문제를 해결하기 위해 바이트 채우기(byte stuffing)라는 방법을 추가로 도입했다. 이 방식에서 만약 데이터 내부에 플래그와 동일한 패턴의 데이터가 생기면 특별한 바이트를 더해 넣는다. 즉 플래그와 똑같은 데이터 부위에 미리 정해진 추가 바이트가 채워진다. 이 추가 바이트를 ESC(escape character,탈출문자)라고 부른다. 수신측에서 이 ESC를 보게 되면 ESC를 제거하고 그 뒤에 나오는 데이터를 플래그가 아닌 데이터로 취급하게 된다.<br>
그런데! ESC가 문자열의 일부라면? <br>
이 문제는 ESC를 앞에 또 추가한다. 즉 2개의 ESC를 통해 '두번째 ESC는 ESC가 아니고 문자열의 일부입니다'라고 알려줘야한다.<br><br>

하지만 그래도 구식은 구식이다. 현대에 유니코드가 16비트나 32비트 워드를 사용하기 때문에 8비트 문자와는 상충한다. 따라서 역사속으로 사라지는 추세다.ㅃㅃ<br>

# 비트 중심 프로토콜

이 방식에서 프레임의 데이터부위는 전부 데이터를 나타내는 비트열이다. 그래도 헤더와 트레일러를 구분하는 경계와 각 프레임 사이를 구분하는 경계는 필요하다. 이 방식도 문자중심프레임짜기 처럼 대체로 01111110이라는 8비트 패턴의 플래그를 두어 경계로 삼고 있다. <br>
하지만 동일한 문제가 생긴다. 플래그의 내용이 데이터 안에 나타나는 경우다. <br>
이럴 때는 1개의 단일 비트를 채워 넣어서 그 패턴이 플래그가 아닌것처럼 보이게 한다. 이 방식은 비트채우기(bit stuffing)이라고 부른다. 위에 문자중심은 바이트 채우기였다. 혼동하지 말자.<br>
비트 채우기에서는 0 뒤에 1이 연속으로 5개가 온다면 추가로 0을 더해 넣는다. 이 추가된 비트는 수신자 측에서 제거된다.<br>
그러니까 01111110이 데이터에서 보이면 011111010으로 바뀐다는 것이다.<br>
진짜 플래그 01111110은 이렇게 0이 추가되지 않는다.<br>
근데 011111010이 원래 데이터인 경우에는 수신자에서 어떻게 처리하지?
