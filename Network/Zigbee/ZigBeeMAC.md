## 직비 MAC 계층

맥 계층은 물리층과 맥층 위의 상위 계층 사이에서 인터페이스를 제공한다. 직비 무선 네트워크에서, 이 다음 상위 계층은 네트워크 층이다. IEEE 802.15.4는 직비만을 위해서 개발된 게 아니다. 그리고 다음 상위 계층은 어떤 프로토콜 계층이라도 될 수 있다.<br>

맥 층은 물리층과 비슷하게 하위 계층에 MLME(MAC Layer Management Entity)라고 부르는 MAC 관리 서비스가 있다. MLME는 네트워크층의 대응되는 것(NLME)과 상호작용을 한다.<br>
맥층은 또한 그것만의 데이터베이스(MAC-PIB라고 참조되는)를 갖고 있다. 모든 맥 구성요소는 a라는 접두어를 갖는다. 맥 속성들은 mac이라는 접두어를 가진다. MAC-PIB의 크기는 PHY-PIB보다 크다. 맥층 구성요소들과 속성들의 테이블은 표준 문서에 포함되어 있다.<br>

###  Beacon-Enabled 동작과 수퍼프레임 구조
비콘 네트워크의 이점 중 하나는 GTSs(Guaranteed Time Slots)의 가용성이다. 비콘 프레임은 비콘과 GTSs의 번호 사이의 시간 간격같은 비콘 정보를 담은 맥 프레임이다. 비콘 포멧은 뒤에서 다시 다룬다.<br>

슈퍼프레임 그림!!!!!!!!!!!!!!!!!!

Beacon-Enabled 동작에서 슈퍼프레임 구조를 사용할 수 있다. 슈퍼프레임은 위 그림처럼 두 개의 비콘 프레임에 의해 묶여있다. 표준문서에서 슈퍼프레임 구조의 사용은 선택적이다. 수퍼프레임은 세 개의 기간(CAP,CFP,inactive period)이 있을 수 있다.

#### contention access period
CAP동안 전송을 하고 싶은 모든 디바이스들은 주파수 채널 접근을 위해 CSMA-CA 메카니즘을 사용해야 한다. 주파수 채널은 같은 네트워크의 모든 디바이스들이 동등하게 사용할 수 있다. 가용 채널의 사용을 시작한 첫 디바이스는 현재의 전송이 완료될 때 까지 그걸 점유한다. 만약 디바이스가 채널이 바쁨을 감지하면 그것은 랜덤기간동안 기다리고 다시 시도한다. 커다란 네트워크 안에서 이것은 대부분의 장치에 대한 채널 접근의 가장 가능성 있는 메커니즘이다. 맥 명령 프레임들은 반드시 CAP기간동안에 전송되어야 한다.
 
#### contention-free period
CAP기간동안에는 어떤 디바이스든 자기가 원할 때 주파수 채널을 사용할 수 있다는 보장이 없다. CFP는 대조적으로 특정 디바이스에게 타임슬롯을 보장한다. 그러므로 디바이스는 CSMA-CA를 채널 접근할 때 사용할 필요가 없다. 이것은 낮은 지연시간을 가지고, 채널이 사용가능해질때까지 랜덤하고 긴 기간동안 기다릴 여유가 없는 디바이스의 어플리케이션들에게 훌륭한 선택지다. CFP동안 CSMA-CA는 사용이 허락되지 않는다.

#### inactive period 
슈퍼프레임은 inactive period를 가질 수도 있다. 이건 디바이스가 절전모드로 들어가는 것을 허락한다. 절전모드동안, 코디네이터는 그것의 송수신기를 꺼서 배터리를 절약할 수 있다.

<br>
슈퍼 프레임 구조는 코디네이터에 의해 정의되고, MLME-START.request primitive를 사용한 네트워크층에 의해 구성된다. BI(Beacon Interval)은 두 연이은 비콘들 사이의 시간 주기다. BI는 macBeaconOrder라는 속성과 aBaseSuperframeDuration 구성요소의 값에 의해 결정된다. 방정식은 아래와 같다.
#### BI = aBaseSuperframeDuration x 2^macBeaconOrder (Symbols)
예를 들어 960 심볼 aBase와 BO가 2라면 비콘 간격은 3840 심볼이다.<br>
macBeaconOrder는 0부터 14사이의 값을 가질 수 있다. 만약에 15가 되면 네트워크는 nonBeacon-Enabled라고 여겨지고 어떤 슈퍼프레임도 응답되지 않는다.
<br>
비슷하게 슈퍼프레임 기간(SD)라고 알려진 슈퍼프레임 엑티브 기간의 길이는 다음 방정식으로 계산된다.
#### SD = aBaseSuperframeDuration x 2^SO (Symbols)
여기서 SO는 macSuperframeOrder 속성의 값이다. 슈퍼프레임 기간은 비콘 간격을 초과할수없다. (BI > SD) 그러므로 SO의 값은 항상 BO의 값보다 작다.
<br>
nonBeacon-Enabled 네트워크(BO가 15인 경우처럼)에서 코디네이터는 네트워크의 디바이스로부터 비콘 요청 명령을 받지 않는 이상 비콘을 전송하지 않는다. <br>
비콘 요청 명령은 코디네이터의 위치를 찾기 위해 디바이스에 의해 사용된다. 비콘 요청 명령의 형식은 뒤에서 다룬다. nonBeacon-Enabled 네트워크의 PAN 코디네이터는 macSuperframeOrder의 값을 15로 설정했다.<br>

Beacon-Enabled 네트워크에서 PAN 코디네이터를 포함한 어떤 코디네이터든 비콘을 전송하는 옵션을 갖고, 그것만의 슈퍼프레임을 만든다. 아래 그림은 PAN 코디네이터와 또다른 코디에니터가 같은 네트워크에서 비콘들을 전송할 때 요구되는 타이밍을 보여준다. 

3.8 그림!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<br>
코디네이터는 PAN코디네이터 슈퍼프레임의 비활성기간(Inactive period)에만 비콘들의 전송을 시작할 수 있다. PAN 코디네이터 비콘은 received beacon으로써 참조된다. 그 외의 다른 코디네이터의 비콘은 transmitted beacon이라고 알려진다. 양쪽 슈퍼프레임의 활성 기간은 반드시 같은 길이여야한다.<br>
PAN코디네이터 이외의 코디네이터는 그것의 슈퍼프레임의 시작을 명시하기 위해 오직 비콘을 전송한다. 그리고 슈퍼프레임의 끝부분은 PAN 코디네이터의 슈퍼프레임과 같을 수 있다.<br>
만약 디바이스가 확장된 기간에 GTS를 사용하지 않는다면, 그것의 GTS는 만료되고 코디네이터는 그 특정 GTS를 다른 디바이스에게 할당할 수 있다. GTS 만료의 결과로 생긴 비활성기간은 항상 슈퍼프레임 두배 길이의 정수배다. 이 정수배의 값은 macBeaconOrder에 달려있다.<br>
BO가 0이상 8이하인 경우, 정수배 = 2^(8-BO) <br>
BO가 8이상 14이하인 경우, 정수배 = 1 <br>
예를 들어 BO가 7인 디바이스는 그것의 GTS를 4개의 연속된 슈퍼프레임동안 사용하지 않으면 GTS는 만료된다.

### Interframe spacing(IFS)
디바이스에서 다른 디바이스로 데이터를 전송할 때, 보낸 측 디바이스는 반드시 성공적으로 전송된 프레임들이 수신측 디바이스가 받은 프레임을 다음 프레임이 도착하기 전에 처리하도록 기다린다. 이건 프레임내 공간할당(IFS)으로 알려져있다. IFS의 길이는 전송된 프레임 크기에 달려있다. aMaxSIFSFrameSize와 같거나 더 작은 사이즈를 가진 MPDU는 짧은 프레임으로 간주된다. 그리고 이것을 초과하는 바이트들을 가진 프레임은 긴 프레임이다. <BR>

짧은 프레임이후의 대기시간은 short IFS라고 참조된다. SIFS의 최소값은 macMinSIFSPeriod다. 비슷하게 긴 프레임은 long IFS(LIFS)에 따른다. aMaxSIFSFrameSize는 12심볼 macMinSIFSPeriod는 40심볼이다.<br>

아래 그림은 인터프레임 공간할당의 두 시나리오를 보여준다.
<br>
그림3.9!!!!!!!!!!!!!!!!!!!!!!!!
<br>
첫 번째는 메시지가 응답되었고 확인응답 프레임 사이의 대기시간을 보여준다. 다음 프레임은 프레임길이에 따라 LIFS와 SIFS다. 프레임 전송하고부터 확인응답을 수신하기까지의 기간은 그림에서 tack으로 나타난다.<br>
두번째 그림은 만약 확인응답이 필요없다면, 최소 인터프레임 공간할당은 프레임이 전송된 시점부터 시작한다.<br>

### CSMA-CA
IEEE 802.15.4가 제공하는 채널 접근 메커니즘은 CSMA-CA다. 디바이스가 전송을 하고싶을때마다 그건 해당 채널이 다른 디바이스에 의해 수행되고 있지 않은것을 확실히하기 위해 CCA를 수행한다. 그리고 디바이스는 그것만의 신호로 전송을 시작한다. 전에도 살펴봤지만 여기선 좀 더 자세히 다룬다.
<br>
비콘들을 전송할때 CSMA-CA를 사용하지 않고 디바이스가 채널을 접근하는 두 가지 경우가 있다.<br>
1. CFP기간동안 채널 엑세스를 하는 경우<br>
2. 데이터 요청 명령을 확인한 즉시 전송. 그러니까, 만약 디바이스가 코디네이터로부터 데이터를 요청하면, 코디네이터는 심지어 CAP 동안에도 CSMA-CA를 수행하지 않고 확인응답과 데이터를 즉시 보낸다.<br>
<br>
CSMA-CA에는 두가지 타입이 있다. slotted와 unslotted다. <br>

#### slotted CSMA-CA
이건 슈퍼프레임 구조가 있는 동안 CSMA-CA를 동작하기 위해 참조된다. 슈퍼프레임은 16개의 똑같은 타임 슬롯들로 엑티브 기간을 나눈다. CSMA-CA 알고리즘의 백오프 기간은 일렬의 특정 타임 슬롯이 되어야 한다.

#### unslotted CSMA-CA
unslotted CSMA-CA 알고리즘은 슈퍼프레임 구조가 없을 때 쓰인다. 결과적으로 백오프 슬롯도 필요없다. 논비콘 네트워크는 항상 이 알고리즘을 채널 엑세스에 사용한다.
<br>
만약 CCA가 바쁜 채널을 표시하면, 디바이스는 랜덤 기간동안 백오프를 하고 다시 시도한다. 슬롯과 언슬롯 CSMA-CA의 랜덤 백오프 기간은 백오프 단위의 정수배다. 백오프 단위 기간은 aUnitBackoffPeriod(맥의 구성요소)와 같다.
<br>

아래 그림은 CSMA-CA의 알고리즘을 보여준다. 
3.10 그림 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<br>

첫번째 단계에서 슬롯이냐 언슬롯이냐가 결정된다. CSMA-CA알고리즘에서는 변수 세 개가 사용된다. BE(backoff exponent), NB(number of back off), CW(contention window)길이 이다.<br>

알고리즘이 바쁜 채널을 만날 떄마다 랜덤 기간동안 백오프를 한다. 그리고 BE는 이 랜덤 기간의 허락된 범위를 결정한다. 이 랜덤 백오프는 단위백오프기간이 곱해진 0부터 2^BE - 1사이의 정수다. <br>

Back-off = (0 ~ 2^BE-1 사이의 랜덤정수) X aUnitBackoffPeriod <br>

언슬롯 CSMA-CA에서 BE의 초기값은 macMinBE와 같다. 슬롯 CSMA-CA에서는 슈퍼프레임 구조에 있는 BLE(Battery Life Extention) 옵션의 선택이 BE 값에 영향을 미친다. 만약 BLE 옵션이 켜지면, 코디네이터는 에너지 절약을 위해 비콘 프레임의 전송에 따른 macBattLifeExtPeriods와 동일한 기간 후에 수신기를 끈다. 이 경우, 백 오프 기간의 범위는 2와 macMinBE중 작은 값으로 제한된다.<br>
BE = min(2,macMinBE)  <br>
만약 BLE 옵션이 선택되지 않으면, 코디네이터는 전체 CAP동안 활성화되고, BE값은 macMinBE와 같아진다. BE값은 CCA가 수행되고 채널이 바쁠때마다 점점 증가된다. 하지만 BE값은 macMaxBE를 초과할 수 없다.<br>
NB는 기기가 정지하고 채널 접근 메커니즘을 재시도하는 횟수를 추적하는 카운터다. 알고리즘의 시작부분에서 NB는 0이다. 그리고 디바이스가 바쁜 채널을 만나서 백오프를 가질때마다 BE는 한번씩 증가한다. 만약 NB가 macMaxCSMABackoffs에 도달하고 여전히 채널이 성공적으로 접근이 불가능하다면, CSMA-CA알고리즘은 중단하고 네트워크층에게 채널접근 실패를 보고한다.<br>

CW(contention window) 변수는 전송을 시작하기 전에 채널을 사용할 수 있어야 하는 백오프 기간을 결정한다. 예를 들어 만약 CW가 2라면, 디바이스는 오직 한가한 채널의 결과인 두 개의 연속된 백오프 후에 전송을 시작한다. CW는 오직 슬롯 CSMA-CA에서만 쓰인다.<br>

만약 전송이 허락된 시간내에 완료되지 못하면, 맥층은 다음 CAP가 시작하고 CSMA-CA 알고리즘을 다시 시도하기까지 기다려야 한다.<br>

### hidden and exposed 노드 문제
CSMA-CA 알고리즘의 약점중 하나가 숨은 노드 문제다.

그림 3.11!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<br>
위 그림에서 a 경우처럼, A와 C는 너무 멀어서 서로의 시그널을 수신할 수 없다. 그러나 A,C는 둘 다 B와 통신할 수 있다. 각 노드에서 안테나로부터의 거리가 증가함에 ㄸ라 신호의 세기는 줄어든다.<br>
C노드가 전송할때 신호 에너지레벨은 A 측에서 탐지할 때 너무 약해서 A의 ED메카니즘이 탐지하지 못하고 해당 주파수 채널이 사용가능하다고 여긴다. 비슷하게 C에서 A의 신호를 받을 때도 마찬가지다. 이제 만약 A,C가 동시에 같은 채널로 B에게 전송해버리면 B에서는 패킷의 충돌이 발생한다.<br>

이 문제를 극복하는 한 방법은 노드의 위치를 바꾸거나 숨겨진 노드의 출력 파워를 높여서 A와 C가 서로의 신호를 탐지할 수 있게끔 하는 것이다. 소프트웨어 레벨에서 IEEE 802.15.4 MAC는 숨겨진 노드 문제를 해결하는 데 거의 도움이 되지 않는다. 예를 들어 IEEE 802.15.4는 숨겨진 노드 문제를 극복하기 위한 노력의 일환으로 IEEE 802.11에서 사용되는 (RTS/CTS) 핸드쉐이크 메커니즘을 현재 지원하지 않는다.
<br>
또다른 CSMA-CA의 약점인 노출된 노드 문제는 그림 B와 같다. 노드F가 노드G에게 메세지를 보내는 동안, 노드 E는 노드 D에게 메세지를 보내려고 한다. 노드 D는 노드 F의 전파 영향 밖에있다. 그러므로 노드 E와 노드 F는 충돌없이 동시에 전송한다. 하지만 CSMA-CA는 노드 E가 전송을 못하게 할 것이다. 왜냐하면 노드 E는 노드 F의 영향권 내에 있어서, 노드 F가 전송하는 동안 노드 E에 의해 수행된 CCA는 채널이 바쁘다고 여길 것이기 때문이다.<br>
이 불필요한 예방을 노출된 노드 문제라고 부른다. 노드의 위치를 바꾸거나, 노드의 출력 레벨을 안정적인 통신에 필요한 최소 요구치까지 줄이고, RTS/CTS 핸드쉐이크 메카니즘을 사용하는 방법들이 이 문제를 해결하는데 추천된다.<br>

## 맥층 서비스

맥 계층은 두가지 타입의 서비스를 제공한다. MAC 데이터 서비스와 MAC 관리 서비스다.<br>
맥 데이터 서비스는 MCPS-SAP(MAC Common Part Sublayer SAP)를 통해 NLDE(NWK Layer Data Entity)에 의해 접근된다. <br>
맥 관리 서비스는 MLME-SAP를 통해 접근된다.<br>
FFD(full function device)는 반드시 전체 맥 데이터 서비스를 구현해야하지만, 맥 관리 서비스에는 FFD를 위한 선택 가능한 기능들이 있다.<br>
맥 데이터 서비스와 맥 관리 서비스 둘 다 FFD를 위해 요구되는 기능들이 있지만, RFD에게는 선택적이다. (문서2 참고)<br>

### 맥 데이터 서비스
맥층은 네트워크층에게 데이터 서비스를 제공한다. 전송되야할 데이터는 NPDU로 제공된다. NPDU는 MSDU라고 불리는 맥층 페이로드에 위치된다. 네트워크층은 MCPS-SAP를 통해 데이터 전송을 위한 요청을 발생시킨다. 그리고 NPDU를 제공한다. <br>

디바이스에서 다른 MSDU들을 추적하기 위해, 각 MSDU는 유일한 MSDU 핸들과 연결된다. 이 msduhandle은 MSDU를 식별하는 정수다. MSDU를 트랜잭션 대기열에서 제거해야 할 경우 MAC 하위 계층은 대기열에서 해당하는 msduhandle을 찾으려고 시도한다.<br>

DSN(Data Sequence Number)는 msduhandle로 사용될 수 있다. DSN은 MAC-PIB에 저장된 맥층의 속성이다. macDSN의 초기값은 랜덤한 숫자이다. 데이터 프레임이나 맥 명령 프레임이 발생되는 각 순간마다, 맥층 하위 계층은 나가는 프레임에 macDSN의 값을 복사하고 macDSN의 값을 하나 증가시킨다.<br>

데이터 전송에는 세가지 옵션이 있다.<br>
1. acknowledged or unacknowledged 전송. <br>
acknowledged 전송은 전송하는 디바이스가 데이터를 받는 디바이스에게 성공적으로 프레임을 받는 경우 확인응답 프레임을 보내달라고 요청하는 것이다.<br>
unacknowledged 전송은 데이터 수신측이 확인응답을 보내주지 않는다. 대체로 확인응답을 보내는 것은 선택이고, 수신측 디바이스는 송신측의 요청이 없는 한 확인응답을 보내지 않는다.<br>

2. GTS or CAP 동안 전송.<br>
논비콘 네트워크에서 이 전송 옵션은 항상 CAP이다. 왜냐하면 GTS에는 논비콘 네트워크가 없기 때문이다.<br>

3. direct or indirect 전송. <br>
이름처럼, 간접(indirect) 전송은 데이터가 수신측 디바이스로 직접적으로 가지 않는다. 대신에 비콘사용 네트워크에서 데이터는 코디네이터에 저장될 수 있고 수신 디바이스는 코디네이터에게 보류중인 데이터가 있다고 통지한다. 이 통지는 정기적으로 전송되는 비콘 메시지의 일부다. 통지를 받은 이후 디바이스는 코디네이터에게 데이터 요청을 보내서 데이터를 전송하게 한다. 오직 코디네이터만 간접 전송을 제어할 수 있다.<br>

<br>
MSDU는 네트워크층의 요청에 의해 트랜잭션 큐에서 버려질 수 있다. 맥 하위계층은 만약 그게 이미 전송되지 않았다면, 간단히 MSDU와 연관된 msduhandle을 찾아서 큐에서 제거한다. 제거능력은 RFD에서는 옵셔널하다.<br>

앞에서 살펴본 데이터 서비스는 데이터 전송을 원하는 디바이스를 위한 것이었다. 만약 디바이스가 데이터를 받고있다면, 맥 데이터 서비스는 네트워크 층에게 그 데이터를 배달한다. 데이터 자체 외에도, MPDU를 수신하는 도중 측정된 링크품질지수와 데이터가 수신된 시간도 네트워크 층에게 제공된다.<br>

### 맥 관리 서비스
맥 관리 서비스는 MLME-SAP를 통해 접근된다. 맥 명령들은 일반적으로 주소,보안필드 같은 파라미터를 포함하고, 다음 상위 계층에게 요청 결과를 상태 형식으로 보고한다. 이 상태는 성공이나 인식불가능 같은 여러개의 옵션들을 가질 수 있다.

#### MAC-PIB 관리
맥 계층은 물리층과 비슷하게 그것만의 구성요소와 속성을 갖는다. 맥 속성들은 MAC-PIB(MAC PAN Information Base)에 저장되고 네트워크층이 접근할 수 있다. <br>

네트워크층은 MAC-PIB의 속성값을 얻기 위해 MLME를 요청할 수 있을 뿐아니라, 또한 PHY-PIB의 속성값도 요청할 수 있다. 후자의 경우, MLME는 간단히 PLME로 요청을 내려보낸다. 그리고 네트워크층에게 PLME로부터 받은 결과를 올려보낸다. <br>

네트워크층은 MLME-SAP를 통해 MAC-PIB 또는 PHY-PIB 속성을 주어진 값으로 설정하도록 MLME에 요청할 수 있다. 네트워크 층은 맥층과 물리층의 PIB들중에 읽기전용 속성을 바꿀 수는 없다. PHY-PIB의 속성을 바꿔달라는 네트워크층의 요청은 MLME에 의해 내려가고 PLME-SAP를 통해 PLME에게 간다.<br>

#### MAC reset
네트워크층은 맥 하위계층을 초기 상태로 리셋시키고, 모든 내부 변수들을 디폴트값으로 바꾸는 MLME를 요청할 수 있다. 이것은 MAC reset operation이라고 알려져있다. 또한 네트워크층은 MAC-PIB 내에 있는 모든 속성들을 디폴트값으로 바꿔달라는 요청을 가진 옵션도 가지고 있다. 맥층은 내부변수와 속성을 초기화하기 전에 송수신기를 비활성화하기 위해 물리층 관리 서비스를 사용한다. <br>

#### Device Association and Disassociation 디바이스 연계와 비연계
association은 디바이스가 네트워크에 참가하기 위한 절차다. 맥 계층은 네트워크 형성을 관리하는 네트워크층에게 연계절차를 서비스로써 제공한다. 대부분의 경우 디바이스는 연계절차를 시작하기 전에 반드시 맥 리셋을 수행해야 한다. <br>

맥 연계절차를 위한 네가지 서비스 프리미티브들이 있다.<br>
#### 1. MLME-Associate.request 
코디네이터에 참가 요청을 하는 디바이스의 네트워크계층에 의해 사용된다. 이 요청은 또한 네트워크에 연결을 요청한 디바이스의 기능들의 리스트를 제공한다. 이 리스트는 디바이스가 FFD인지 RFD인지 결정한다.<br>
네트워크에 참여하고 싶은 디바이스의 맥 계층이 그것의 네트워크계층으로부터 연계요청을 받았을 때, 그 명령을 물리층에게 MPDU로 내려준다. 그 MPDU는 물리층 페이로드가 되고, 코디네이터 디바이스에게 전송된다. 코디네이터 응답이 디바이스에게 도착했을 때 디바이스의 맥계층은 그 확인(MLME-Associate.confirm)을 네트워크 계층에게 전달한다. <br>

코디네이터 측에서, 코디네이터의 맥층이 연계요청을 받았을 때, 코디네이터의 네트워크층에게 그 요청에 대해 알리기 위해 MLME-Associate.indication 플미티브를 사용한다. 대신에 코디네이터 MLME는 간접 전송을 사용한다. 그러므로 데이터는 코디네이터에 저장된다. 비연계 디바이스는 디바이스가 연계요청을 보낸 순간부터 미리 지정된 시간동안 기다린 후에 코디네이터에게 데이터 요청을 보낸다. 이 필요한 대기 시간의 길이는 MAC-PIB의 속성으로써 디바이스에 저장된다. <br>
연계절차는 밑에 시퀀스 차트로 나타냈다.

그림 3.12!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11

<br>
MLME COMM-STATUS.indication primitive는 처리 상태(성공,실패)를 네트워크층에게 제공한다. 네트워크에 성공적으로 연계된 디바이스는 연계 디바이스라고 알려진다.<br>
disassociation은 연계된 디바이스가 코디네이터에게 그 디바이스가 

#### 2. MLME-Associate.indication  
#### 3. MLME-Associate.response   
#### 4. MLME-Associate.confirm    


