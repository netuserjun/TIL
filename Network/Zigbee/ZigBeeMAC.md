## 직비 MAC 계층

맥 계층은 물리층과 맥층 위의 상위 계층 사이에서 인터페이스를 제공한다. 직비 무선 네트워크에서, 이 다음 상위 계층은 네트워크 층이다. IEEE 802.15.4는 직비만을 위해서 개발된 게 아니다. 그리고 다음 상위 계층은 어떤 프로토콜 계층이라도 될 수 있다.<br>

MAC는 다음과 같은 업무를 수행한다. <br>
● 비콘 생성(디바이스가 코디네이터인 경우) <br>
● 비콘에 기기 동기화(비콘 사용 네트워크) <br>
● 채널 접속에 CSMA-CA 활용 <br>
● GTS 채널 접속 관리 <br>
● 2개의 동위 MAC 엔티티(두 개의 다른 장치) 간에 신뢰할 수 있는 링크 제공<br>
● PAN 연결 및 해제 서비스 제공 <br>
● 보안 지원; MAC 계층은 자체 보안 처리를 담당하지만, 상위 계층은 PAN을 사용할 보안 수준을 결정한다.<br>

맥 층은 물리층과 비슷하게 하위 계층에 MLME(MAC Layer Management Entity)라고 부르는 MAC 관리 서비스가 있다. MLME는 네트워크층의 대응되는 것(NLME)과 상호작용을 한다.<br>
맥층은 또한 그것만의 데이터베이스(MAC-PIB라고 참조되는)를 갖고 있다. 모든 맥 상수는 a라는 접두어를 갖는다. 맥 속성들은 mac이라는 접두어를 가진다. MAC-PIB의 크기는 PHY-PIB보다 크다. 맥층들과 속성들의 테이블은 표준 문서에 포함되어 있다.<br>

###  Beacon-Enabled 동작과 수퍼프레임 구조
비콘 네트워크의 이점 중 하나는 GTSs(Guaranteed Time Slots)의 가용성이다. 비콘 프레임은 비콘과 GTSs의 번호 사이의 시간 간격같은 비콘 정보를 담은 맥 프레임이다. 비콘 포멧은 뒤에서 다시 다룬다.<br>

![image](https://user-images.githubusercontent.com/38284141/52639855-92cade00-2f18-11e9-8da1-2cdd4c019d4c.png)

Beacon-Enabled 동작에서 슈퍼프레임 구조를 사용할 수 있다. 슈퍼프레임은 위 그림처럼 두 개의 비콘 프레임에 의해 묶여있다. 표준문서에서 슈퍼프레임 구조의 사용은 선택적이다. 수퍼프레임은 세 개의 기간(CAP,CFP,inactive period)이 있을 수 있다.

#### contention access period
CAP동안 전송을 하고 싶은 모든 디바이스들은 주파수 채널 접근을 위해 CSMA-CA 메카니즘을 사용해야 한다. 주파수 채널은 같은 네트워크의 모든 디바이스들이 동등하게 사용할 수 있다. 가용 채널의 사용을 시작한 첫 디바이스는 현재의 전송이 완료될 때 까지 그걸 점유한다. 만약 디바이스가 채널이 바쁨을 감지하면 그것은 랜덤기간동안 기다리고 다시 시도한다. 커다란 네트워크 안에서 이것은 대부분의 장치에 대한 채널 접근의 가장 가능성 있는 메커니즘이다. 맥 명령 프레임들은 반드시 CAP기간동안에 전송되어야 한다.
 
#### contention-free period
CAP기간동안에는 어떤 디바이스든 자기가 원할 때 주파수 채널을 사용할 수 있다는 보장이 없다. CFP는 대조적으로 특정 디바이스에게 타임슬롯을 보장한다. 그러므로 디바이스는 CSMA-CA를 채널 접근할 때 사용할 필요가 없다. 이것은 낮은 지연시간을 가지고, 채널이 사용가능해질때까지 랜덤하고 긴 기간동안 기다릴 여유가 없는 디바이스의 어플리케이션들에게 훌륭한 선택지다. CFP동안 CSMA-CA는 사용이 허락되지 않는다.

#### inactive period 
슈퍼프레임은 inactive period를 가질 수도 있다. 이건 디바이스가 절전모드로 들어가는 것을 허락한다. 절전모드동안, 코디네이터는 그것의 송수신기를 꺼서 배터리를 절약할 수 있다.

<br>
슈퍼 프레임 구조는 코디네이터에 의해 정의되고, MLME-START.request primitive를 사용한 네트워크층에 의해 구성된다. BI(Beacon Interval)은 두 연이은 비콘들 사이의 시간 주기다. BI는 macBeaconOrder라는 속성과 aBaseSuperframeDuration 구성요소의 값에 의해 결정된다. 방정식은 아래와 같다.
#### BI = aBaseSuperframeDuration x 2^macBeaconOrder (Symbols)
예를 들어 960 심볼 aBase와 BO가 2라면 비콘 간격은 3840 심볼이다.<br>
macBeaconOrder는 0부터 14사이의 값을 가질 수 있다. 만약에 15가 되면 네트워크는 nonBeacon-Enabled라고 여겨지고 어떤 슈퍼프레임도 응답되지 않는다.
<br>
비슷하게 슈퍼프레임 기간(SD)라고 알려진 슈퍼프레임 엑티브 기간의 길이는 다음 방정식으로 계산된다.
#### SD = aBaseSuperframeDuration x 2^SO (Symbols)
여기서 SO는 macSuperframeOrder 속성의 값이다. 슈퍼프레임 기간은 비콘 간격을 초과할수없다. (BI > SD) 그러므로 SO의 값은 항상 BO의 값보다 작다.
<br>
nonBeacon-Enabled 네트워크(BO가 15인 경우처럼)에서 코디네이터는 네트워크의 디바이스로부터 비콘 요청 명령을 받지 않는 이상 비콘을 전송하지 않는다. <br>
비콘 요청 명령은 코디네이터의 위치를 찾기 위해 디바이스에 의해 사용된다. 비콘 요청 명령의 형식은 뒤에서 다룬다. nonBeacon-Enabled 네트워크의 PAN 코디네이터는 macSuperframeOrder의 값을 15로 설정했다.<br>

Beacon-Enabled 네트워크에서 PAN 코디네이터를 포함한 어떤 코디네이터든 비콘을 전송하는 옵션을 갖고, 그것만의 슈퍼프레임을 만든다. 아래 그림은 PAN 코디네이터와 또다른 코디에니터가 같은 네트워크에서 비콘들을 전송할 때 요구되는 타이밍을 보여준다. 
<br>
![image](https://user-images.githubusercontent.com/38284141/52640832-c444a900-2f1a-11e9-8e1b-6c41e92f42e8.png)
<br>
코디네이터는 PAN코디네이터 슈퍼프레임의 비활성기간(Inactive period)에만 비콘들의 전송을 시작할 수 있다. PAN 코디네이터 비콘은 received beacon으로써 참조된다. 그 외의 다른 코디네이터의 비콘은 transmitted beacon이라고 알려진다. 양쪽 슈퍼프레임의 활성 기간은 반드시 같은 길이여야한다.<br>
PAN코디네이터 이외의 코디네이터는 그것의 슈퍼프레임의 시작을 명시하기 위해 오직 비콘을 전송한다. 그리고 슈퍼프레임의 끝부분은 PAN 코디네이터의 슈퍼프레임과 같을 수 있다.<br>
만약 디바이스가 확장된 기간에 GTS를 사용하지 않는다면, 그것의 GTS는 만료되고 코디네이터는 그 특정 GTS를 다른 디바이스에게 할당할 수 있다. GTS 만료의 결과로 생긴 비활성기간은 항상 슈퍼프레임 두배 길이의 정수배다. 이 정수배의 값은 macBeaconOrder에 달려있다.<br>
BO가 0이상 8이하인 경우, 정수배 = 2^(8-BO) <br>
BO가 8이상 14이하인 경우, 정수배 = 1 <br>
예를 들어 BO가 7인 디바이스는 그것의 GTS를 4개의 연속된 슈퍼프레임동안 사용하지 않으면 GTS는 만료된다.

### Interframe spacing(IFS)
디바이스에서 다른 디바이스로 데이터를 전송할 때, 보낸 측 디바이스는 반드시 수신측 디바이스가 다음 프레임이 도착하기 전에 성공적으로 수신된 프레임들을 처리하도록 기다린다. 이건 프레임내 공간할당(IFS)으로 알려져있다. IFS의 길이는 전송된 프레임 크기에 달려있다. aMaxSIFSFrameSize와 같거나 더 작은 사이즈를 가진 MPDU는 짧은 프레임으로 간주된다. 그리고 이것을 초과하는 바이트들을 가진 프레임은 긴 프레임이다. <BR>

짧은 프레임이후의 대기시간은 short IFS라고 참조된다. SIFS의 최소값은 macMinSIFSPeriod다. 비슷하게 긴 프레임은 long IFS(LIFS)에 따른다. aMaxSIFSFrameSize는 12심볼 macMinSIFSPeriod는 40심볼이다.<br>

아래 그림은 인터프레임 공간할당의 두 시나리오를 보여준다.
<br>
![image](https://user-images.githubusercontent.com/38284141/52643542-9c584400-2f20-11e9-8c04-2a29adc60f8e.png)
<br>
첫 번째는 메시지가 응답되었고 확인응답 프레임 사이의 대기시간을 보여준다. 다음 프레임은 프레임길이에 따라 LIFS와 SIFS다. 프레임 전송하고부터 확인응답을 수신하기까지의 기간은 그림에서 tack으로 나타난다.<br>
두번째 그림은 만약 확인응답이 필요없다면, 최소 인터프레임 공간할당은 프레임이 전송된 시점부터 시작한다.<br>

### CSMA-CA
IEEE 802.15.4가 제공하는 채널 접근 메커니즘은 CSMA-CA다. 디바이스가 전송을 하고싶을때마다 그건 해당 채널이 다른 디바이스에 의해 수행되고 있지 않은것을 확실히하기 위해 CCA를 수행한다. 그리고 디바이스는 그것만의 신호로 전송을 시작한다. 전에도 살펴봤지만 여기선 좀 더 자세히 다룬다.
<br>
비콘들을 전송할때 CSMA-CA를 사용하지 않고 디바이스가 채널을 접근하는 두 가지 경우가 있다.<br>
1. CFP기간동안 채널 엑세스를 하는 경우<br>
2. 데이터 요청 명령을 확인한 즉시 전송. 그러니까, 만약 디바이스가 코디네이터로부터 데이터를 요청하면, 코디네이터는 심지어 CAP 동안에도 CSMA-CA를 수행하지 않고 확인응답과 데이터를 즉시 보낸다.<br>
<br>
CSMA-CA에는 두가지 타입이 있다. slotted와 unslotted다. <br>

#### slotted CSMA-CA
이건 슈퍼프레임 구조가 있는 동안 CSMA-CA를 동작하기 위해 참조된다. 슈퍼프레임은 16개의 똑같은 타임 슬롯들로 엑티브 기간을 나눈다. CSMA-CA 알고리즘의 백오프 기간은 일렬의 특정 타임 슬롯이 되어야 한다.

#### unslotted CSMA-CA
unslotted CSMA-CA 알고리즘은 슈퍼프레임 구조가 없을 때 쓰인다. 결과적으로 백오프 슬롯도 필요없다. 논비콘 네트워크는 항상 이 알고리즘을 채널 엑세스에 사용한다.
<br>
만약 CCA가 바쁜 채널을 표시하면, 디바이스는 랜덤 기간동안 백오프를 하고 다시 시도한다. 슬롯과 언슬롯 CSMA-CA의 랜덤 백오프 기간은 백오프 단위의 정수배다. 백오프 단위 기간은 aUnitBackoffPeriod(맥의 구성요소)와 같다.
<br>

아래 그림은 CSMA-CA의 알고리즘을 보여준다. 
![image](https://user-images.githubusercontent.com/38284141/52645873-ffe47080-2f24-11e9-9552-24a51f3cb56f.png)
<br>

첫번째 단계에서 슬롯이냐 언슬롯이냐가 결정된다. CSMA-CA알고리즘에서는 변수 세 개가 사용된다. BE(backoff exponent), NB(number of back off), CW(contention window)길이 이다.<br>

알고리즘이 바쁜 채널을 만날 떄마다 랜덤 기간동안 백오프를 한다. 그리고 BE는 이 랜덤 기간의 허락된 범위를 결정한다. 이 랜덤 백오프는 단위백오프기간이 곱해진 0부터 2^BE - 1사이의 정수다. <br>

Back-off = (0 ~ 2^BE-1 사이의 랜덤정수) X aUnitBackoffPeriod <br>

언슬롯 CSMA-CA에서 BE의 초기값은 macMinBE와 같다. 슬롯 CSMA-CA에서는 슈퍼프레임 구조에 있는 BLE(Battery Life Extention) 옵션의 선택이 BE 값에 영향을 미친다. 만약 BLE 옵션이 켜지면, 코디네이터는 에너지 절약을 위해 비콘 프레임의 전송에 따른 macBattLifeExtPeriods와 동일한 기간 후에 수신기를 끈다. 이 경우, 백 오프 기간의 범위는 2와 macMinBE중 작은 값으로 제한된다.<br>
BE = min(2,macMinBE)  <br>
만약 BLE 옵션이 선택되지 않으면, 코디네이터는 전체 CAP동안 활성화되고, BE값은 macMinBE와 같아진다. BE값은 CCA가 수행되고 채널이 바쁠때마다 점점 증가된다. 하지만 BE값은 macMaxBE를 초과할 수 없다.<br>
NB는 기기가 정지하고 채널 접근 메커니즘을 재시도하는 횟수를 추적하는 카운터다. 알고리즘의 시작부분에서 NB는 0이다. 그리고 디바이스가 바쁜 채널을 만나서 백오프를 가질때마다 BE는 한번씩 증가한다. 만약 NB가 macMaxCSMABackoffs에 도달하고 여전히 채널이 성공적으로 접근이 불가능하다면, CSMA-CA알고리즘은 중단하고 네트워크층에게 채널접근 실패를 보고한다.<br>

CW(contention window) 변수는 전송을 시작하기 전에 채널을 사용할 수 있어야 하는 백오프 기간을 결정한다. 예를 들어 만약 CW가 2라면, 디바이스는 오직 한가한 채널의 결과인 두 개의 연속된 백오프 후에 전송을 시작한다. CW는 오직 슬롯 CSMA-CA에서만 쓰인다.<br>

만약 전송이 허락된 시간내에 완료되지 못하면, 맥층은 다음 CAP가 시작하고 CSMA-CA 알고리즘을 다시 시도하기까지 기다려야 한다.<br>

### hidden and exposed 노드 문제
CSMA-CA 알고리즘의 약점중 하나가 숨은 노드 문제다.

![image](https://user-images.githubusercontent.com/38284141/52646048-5ea9ea00-2f25-11e9-8920-24ba853d4f46.png)
<br>
위 그림에서 a 경우처럼, A와 C는 너무 멀어서 서로의 시그널을 수신할 수 없다. 그러나 A,C는 둘 다 B와 통신할 수 있다. 각 노드에서 안테나로부터의 거리가 증가함에 따라 신호의 세기는 줄어든다.<br>
C노드가 전송할때 신호 에너지레벨은 A 측에서 탐지할 때 너무 약해서 A의 ED메카니즘이 탐지하지 못하고 해당 주파수 채널이 사용가능하다고 여긴다. 비슷하게 C에서 A의 신호를 받을 때도 마찬가지다. 이제 만약 A,C가 동시에 같은 채널로 B에게 전송해버리면 B에서는 패킷의 충돌이 발생한다.<br>

이 문제를 극복하는 한 방법은 노드의 위치를 바꾸거나 숨겨진 노드의 출력 파워를 높여서 A와 C가 서로의 신호를 탐지할 수 있게끔 하는 것이다. 소프트웨어 레벨에서 IEEE 802.15.4 MAC는 숨겨진 노드 문제를 해결하는 데 거의 도움이 되지 않는다. 예를 들어 IEEE 802.15.4는 숨겨진 노드 문제를 극복하기 위한 노력의 일환으로 IEEE 802.11에서 사용되는 (RTS/CTS) 핸드쉐이크 메커니즘을 현재 지원하지 않는다.
<br>
또다른 CSMA-CA의 약점인 노출된 노드 문제는 그림 B와 같다. 노드F가 노드G에게 메세지를 보내는 동안, 노드 E는 노드 D에게 메세지를 보내려고 한다. 노드 D는 노드 F의 전파 영향 밖에있다. 그러므로 노드 E와 노드 F는 충돌없이 동시에 전송한다. 하지만 CSMA-CA는 노드 E가 전송을 못하게 할 것이다. 왜냐하면 노드 E는 노드 F의 영향권 내에 있어서, 노드 F가 전송하는 동안 노드 E에 의해 수행된 CCA는 채널이 바쁘다고 여길 것이기 때문이다.<br>
이 불필요한 예방을 노출된 노드 문제라고 부른다. 노드의 위치를 바꾸거나, 노드의 출력 레벨을 안정적인 통신에 필요한 최소 요구치까지 줄이고, RTS/CTS 핸드쉐이크 메카니즘을 사용하는 방법들이 이 문제를 해결하는데 추천된다.<br>

# 맥층 서비스

맥 계층은 두가지 타입의 서비스를 제공한다. MAC 데이터 서비스와 MAC 관리 서비스다.<br>
맥 데이터 서비스는 MCPS-SAP(MAC Common Part Sublayer SAP)를 통해 NLDE(NWK Layer Data Entity)에 의해 접근된다. <br>
맥 관리 서비스는 MLME-SAP를 통해 접근된다.<br>
FFD(full function device)는 반드시 전체 맥 데이터 서비스를 구현해야하지만, 맥 관리 서비스에는 FFD를 위한 선택 가능한 기능들이 있다.<br>
맥 데이터 서비스와 맥 관리 서비스 둘 다 FFD를 위해 요구되는 기능들이 있지만, RFD에게는 선택적이다. (문서2 참고)<br>

## 맥 데이터 서비스
맥층은 네트워크층에게 데이터 서비스를 제공한다. 전송되야할 데이터는 NPDU로 제공된다. NPDU는 MSDU라고 불리는 맥층 페이로드에 위치된다. 네트워크층은 MCPS-SAP를 통해 데이터 전송을 위한 요청을 발생시킨다. 그리고 NPDU를 제공한다. <br>

디바이스에서 다른 MSDU들을 추적하기 위해, 각 MSDU는 유일한 MSDU 핸들과 연결된다. 이 msduhandle은 MSDU를 식별하는 정수다. MSDU를 트랜잭션 대기열에서 제거해야 할 경우 MAC 하위 계층은 대기열에서 해당하는 msduhandle을 찾으려고 시도한다.<br>

DSN(Data Sequence Number)는 msduhandle로 사용될 수 있다. DSN은 MAC-PIB에 저장된 맥층의 속성이다. macDSN의 초기값은 랜덤한 숫자이다. 데이터 프레임이나 맥 명령 프레임이 발생되는 각 순간마다, 맥층 하위 계층은 나가는 프레임에 macDSN의 값을 복사하고 macDSN의 값을 하나 증가시킨다.<br>

데이터 전송에는 세가지 옵션이 있다.<br>
1. acknowledged or unacknowledged 전송. <br>
acknowledged 전송은 전송하는 디바이스가 데이터를 받는 디바이스에게 성공적으로 프레임을 받는 경우 확인응답 프레임을 보내달라고 요청하는 것이다.<br>
unacknowledged 전송은 데이터 수신측이 확인응답을 보내주지 않는다. 대체로 확인응답을 보내는 것은 선택이고, 수신측 디바이스는 송신측의 요청이 없는 한 확인응답을 보내지 않는다.<br>

2. GTS or CAP 동안 전송.<br>
논비콘 네트워크에서 이 전송 옵션은 항상 CAP이다. 왜냐하면 GTS에는 논비콘 네트워크가 없기 때문이다.<br>

3. direct or indirect 전송. <br>
이름처럼, 간접(indirect) 전송은 데이터가 수신측 디바이스로 직접적으로 가지 않는다. 대신에 비콘사용 네트워크에서 데이터는 코디네이터에 저장될 수 있고 수신 디바이스는 코디네이터에게 보류중인 데이터가 있다고 통지한다. 이 통지는 정기적으로 전송되는 비콘 메시지의 일부다. 통지를 받은 이후 디바이스는 코디네이터에게 데이터 요청을 보내서 데이터를 전송하게 한다. 오직 코디네이터만 간접 전송을 제어할 수 있다.<br>

<br>
MSDU는 네트워크층의 요청에 의해 트랜잭션 큐에서 버려질 수 있다. 맥 하위계층은 만약 그게 이미 전송되지 않았다면, 간단히 MSDU와 연관된 msduhandle을 찾아서 큐에서 제거한다. 제거능력은 RFD에서는 옵셔널하다.<br>

앞에서 살펴본 데이터 서비스는 데이터 전송을 원하는 디바이스를 위한 것이었다. 만약 디바이스가 데이터를 받고있다면, 맥 데이터 서비스는 네트워크 층에게 그 데이터를 배달한다. 데이터 자체 외에도, MPDU를 수신하는 도중 측정된 링크품질지수와 데이터가 수신된 시간도 네트워크 층에게 제공된다.<br>

## 맥 관리 서비스
맥 관리 서비스는 MLME-SAP를 통해 접근된다. 맥 명령들은 일반적으로 주소,보안필드 같은 파라미터를 포함하고, 다음 상위 계층에게 요청 결과를 상태 형식으로 보고한다. 이 상태는 성공이나 인식불가능 같은 여러개의 옵션들을 가질 수 있다.

### MAC-PIB 관리
맥 계층은 물리층과 비슷하게 그것만의 구성요소와 속성을 갖는다. 맥 속성들은 MAC-PIB(MAC PAN Information Base)에 저장되고 네트워크층이 접근할 수 있다. <br>

네트워크층은 MAC-PIB의 속성값을 얻기 위해 MLME를 요청할 수 있을 뿐아니라, 또한 PHY-PIB의 속성값도 요청할 수 있다. 후자의 경우, MLME는 간단히 PLME로 요청을 내려보낸다. 그리고 네트워크층에게 PLME로부터 받은 결과를 올려보낸다. <br>

네트워크층은 MLME-SAP를 통해 MAC-PIB 또는 PHY-PIB 속성을 주어진 값으로 설정하도록 MLME에 요청할 수 있다. 네트워크 층은 맥층과 물리층의 PIB들중에 읽기전용 속성을 바꿀 수는 없다. PHY-PIB의 속성을 바꿔달라는 네트워크층의 요청은 MLME에 의해 내려가고 PLME-SAP를 통해 PLME에게 간다.<br>

### MAC reset
네트워크층은 맥 하위계층을 초기 상태로 리셋시키고, 모든 내부 변수들을 디폴트값으로 바꾸는 MLME를 요청할 수 있다. 이것은 MAC reset operation이라고 알려져있다. 또한 네트워크층은 MAC-PIB 내에 있는 모든 속성들을 디폴트값으로 바꿔달라는 요청을 가진 옵션도 가지고 있다. 맥층은 내부변수와 속성을 초기화하기 전에 송수신기를 비활성화하기 위해 물리층 관리 서비스를 사용한다. <br>

### Device Association and Disassociation 디바이스 연계와 비연계
association은 디바이스가 네트워크에 참가하기 위한 절차다. 맥 계층은 네트워크 형성을 관리하는 네트워크층에게 연계절차를 서비스로써 제공한다. 대부분의 경우 디바이스는 연계절차를 시작하기 전에 반드시 맥 리셋을 수행해야 한다. <br>

맥 연계절차를 위한 네가지 서비스 프리미티브들이 있다.<br>
#### 1. MLME-Associate.request 
#### 2. MLME-Associate.indication  
#### 3. MLME-Associate.response   
#### 4. MLME-Associate.confirm    

MLME-Associate.request는 코디네이터에 참가 요청을 하는 디바이스의 네트워크계층에 의해 사용된다. 이 요청은 또한 네트워크에 연결을 요청한 디바이스의 기능들의 리스트를 제공한다. 이 리스트는 디바이스가 FFD인지 RFD인지 결정한다.<br>
네트워크에 참여하고 싶은 디바이스의 맥 계층이 그것의 네트워크계층으로부터 연계요청을 받았을 때, 그 명령을 물리층에게 MPDU로 내려준다. 그 MPDU는 물리층 페이로드가 되고, 코디네이터 디바이스에게 전송된다. 코디네이터 응답이 디바이스에게 도착했을 때 디바이스의 맥계층은 그 확인(MLME-Associate.confirm)을 네트워크 계층에게 전달한다. <br>

코디네이터 측에서, 코디네이터의 맥층이 연계요청을 받았을 때, 코디네이터의 네트워크층에게 그 요청에 대해 알리기 위해 MLME-Associate.indication 플미티브를 사용한다. 대신에 코디네이터 MLME는 간접 전송을 사용한다. 그러므로 데이터는 코디네이터에 저장된다. 비연계 디바이스는 디바이스가 연계요청을 보낸 순간부터 미리 지정된 시간동안 기다린 후에 코디네이터에게 데이터 요청을 보낸다. 이 필요한 대기 시간의 길이는 MAC-PIB의 속성으로써 디바이스에 저장된다. <br>
연계절차는 밑에 시퀀스 차트로 나타냈다.

그림 3.12!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!11

<br>
MLME COMM-STATUS.indication primitive는 처리 상태(성공,실패)를 네트워크층에게 제공한다. 네트워크에 성공적으로 연계된 디바이스는 연계 디바이스라고 알려진다.<br>
disassociation은 연계된 디바이스가 코디네이터에게 그 디바이스가 네트워크를 떠난다고 알릴때의 절차다. 연계된 디바이스의 네트워크층은 MLME-DISASSOCIATE.request 프리미티브를 사용해서 그것의 MLME로 분리명령을 발생시킨다. 이 요청은 물리층 데이터 서비스로 코디네이터에게 보내진다. 이 분리요청에서 디바이스는 요청의 이유를 제공한다. 그 이유는 다음중 하나가 될 수 있다.<br>
1. 코디네이터가 디바이스를 PAN에서 내보내고 싶어함.<br>
2. 디바이스가 PAN에서 떠나고 싶어함.<br>

코디네이터 MLME는 그 요청을 분석하고 만약 모든 주소할당, 보안필드가 유효하면, 코디네이터는 디바이스의 분리가 성공적이라는 확인을 보내준다.<br>
이 확인은 직접 혹은 간접적인 전송 메카니즘으로 디바이스에게 전달된다. 선호하는 전송 방법은 MLME-DISASSOCIATE.request에 명시되어 있다.<br>

코디네이터 MLME는 네트워크층에게 해당 네트워크에 있는 디바이스의 분리 요청의 결과에 관해 알리기 위해 MLME-DISASSOCIATE.indication 프리미티브를 사용한다. 아래 그림은 분리절차의 시퀀스 차트다.
<br>
그림 3.13!!!!!!!!!!!!!!!!!!!!!!!!11
<br>
분리 요청은 코디네이터나 디바이스에 의해 개시될 수 있다. 위 그림에서 a 경우는 디바이스가 분리 절차를 개시했을 때 일어나는 순서를 보여준다.<br>
만약 코디네이터가 비콘사용 네트워크에서 분리를 개시한다면, 간접 전송을 채택할 것이다. b그림에서 코디네이터는 주기적으로 방송되는 비콘의 일부로 디바이스에 대한 보류 중인 데이터가 있음을 디바이스에 통지한다. 비콘을 보낸 이후, 디바이스는 데이터를 요청하고 분리 통지를 받는다. MLME-DISASSOCIATE.confirm은 항상 분리를 요청한 장치의 NWK 레이어가 요청의 결과를 알 수 있도록 하기 위해 사용된다.<br>

### communication status 통신상태
MLME는 전송상태와 같은 정보를 네트워크 계층에게 제공하기 위해 MLME-COMM-STATUS.indication 프리미티브를 사용한다. 이 프리미티브는 또한 들어온 퍀ㅅ의 보안과 관련된 에러를 보고하기 위해 MLME에 의해 사용된다. 만약 통신이 실패했다면, 프리미티브는 또한 실패의 이유를 제공한다. 지원되지 않는 보안특징이나 채널 접근실패들은 통신 실패의 이유다.<br>

### 수신기 활성화와 비활성화
네트워크층은 일정한 시간 동안 수신기를 활성화하도록 MLME를 요청할 수 있다. 수신기가 켜져있을 기간은 네트워크층에 의해 제공된다. 네트워크층은 또한 수신기를 꺼달라고 요청할 수도 있다. 이것들은 FFD와 RFD 둘다 선택적인 기능이다.<br>
활성화와 비활성화 요청들은 다른 MLME 책임에 보조적인 것으로 다루어진다. 예를 들어서 만약 MLME가 비콘 전송과 같은 상충되는 책임을 갖고 있다면 MLME는 네트워크 계층의 수신기를 켜달라는 요청을 무시할 것이다. MLME는 항상 수신기 활성화나 비활성화 요청에 대한 결과를 네트워크 층에게 알려준다.<br>

### GTS 관리

비콘 사용 네트워크에서, 디바이스가 CSMA-CA를 사용하지 않고 전송에 사용할 수 있는 GTSs가 있다. 디바이스의 네트워크 계층은 새로운 GTS 할당을 요청하는데 MAC 관리 서비스를 사용할 수 있다. 만약 디바이스가 이미 할당된 GTS를 가지고 있고, 더 이상 필요하지 않다면, MLME는 PAN 코디네이터에게 존재하는 GTS를 할당취소해달라고 요청할 수 있다. PAN 코디네이터의 네트워크계층은 또한 해당 네트워크에 존재하는 디바이스에게 할당된 GTS를 할당취소해달라고 그것의 MLME를 요청할 수 있다.<br>

PAN 코디네이터는 GTS 요청을 수용하거나 취소하는 선택지가 있다. 만약 PAN 코디네이터가 GTS 할당을 수용했다면, PAN 코디네이터는 GTS의 길이와 같은 특징을 응답에 포함시킨다. GTS 요청 프리미티브는  MLMEGTS.request 이고, 네트워크계층에 의해 MLME로 알려진다. MLME는 GTS 요청의 결과를 MLME-GTS.confirm premary를 사용하여 NWK 레이어로 다시 전달한다. PAN 코디네이터에서 네트워크의 다른 디바이스로부터 요청을 받는 것에 기초해서 GTS들중 하나를 할당하거나 할당해제를 할때마다 MLME는 네트워크 계층에 알리기 위해 MLME-GTS.indication 프리미티브를 사용한다.<br>
만약에 네트워크 계층이 GTS 할당이나 할당해제 요청을 했다면, 그것의 MLME는 네트워크 계층에게 MLME-GTS.confirm 프리미티브를 사용해서 알려줄 것이다.
<br>

아래 그림은 디바이스에 의해 개시된 GTS 할당을 시퀀스 차트로 보여준다.<br>
그림 3.14 !!!!!!!!!!!!!!!!!!!!!!!11
<br>
아래 그림은 두개의 다른 할당해제 시나리오를 시퀀스 차트로 보여준다. <br>
그림 3.15!!!!!!!!!!!!!!!!!!!!!!11
<br>
위 그림에서 a 경우는 디바이스가 요청을 개시했을때의 할당해제 절차다. <br>
b 경우는 PAN 코디네이터가 개시자일때다. <br>

GTS 할당해제는 CAP에 사용되지 않은 간격을 남길 수 있다. 예를 들어 밑에 그림에서 GTS2는 할당 해제 되었고 타임슬롯 11부터 13은 더이상 어떤 디바이스에 의해서도 사용되지 않는다.<br>
그림 3.16 !!!!!!!!!!!!!!!!!!11
<br>
이것은 슈퍼프레임의 조각화라고 알려져있다. 이 조각 문제를 고치고 CAP를 증가시키기 위해서, GTS2는 제거되고 GTS3은 간단히 타임슬롯 12와 13에 재할당된다. 이 GTS 재할당의 결과로, CAP은 9부터 12 타임슬롯까지 증가됐다.

### 슈퍼프레임 구성 업데이트
비콘 사용 네트워크에서 네트워크층은 슈퍼프레임 구조를 시작하기 위해 MLME를 요청할 수 있다. 네트워크 계층은 활성 기간의 길이와 비콘이 전송되어야 하는 빈도를 포함하되 이에 국한되지 않는 필요한 매개변수를 제공한다.<br>
슈퍼프레임 구성에 있는 참조변수들 중의 하나는 BLE 옵션이다. 이 옵션은 배터리 에너지 절약을 위해 비컨 프레임을 전송한 후 비커닝 코디네이터가 macBattLifeExtPeriods와 동일한 시간 동안 수신기를 끌 수 있도록 한다. 이 기간은 프레임 전송 후 필요한 IFS 기간에 추가된다. 만약 BLE 옵션이 꺼져있으면, 비코닝 코디네이터는 반드시 그것의 수신기를 CAP 전체동안 활성화를 유지해야한다.

### orphan notification
디바이스는 네트워크에 있는 다른 디바이스와 통신하기 위해서 반드시 네트워크에 연계되어 있어야 한다. 전에는 네트워크와 연계되어 있었지만 그 연계를 잃은 디바이스는 고아 디바이스로 간주된다. 네트워크에 남아서 해제 절차를 사용하는 디바이스는 고아 디바이스로 간주되지 않는다. 만약 디바이스의 네트워크 계층이 반복적인 통신 실패를 만나면, 그것은 그 디바이스가 고아가 됐다고 결론내릴 수도 있다.
<br>
<br>
예를 들어, 기기가 수신확인이 필요한 프레임을 전송하고 macAckWaitDuration 심볼을 기다린 후 수신확인을 받지 못하는 경우, 기기는 macMaxFrameRetire까지 데이터 전송을 반복할 수 있다. macMaxFrameRetire 시도 이후에도 여전히 확인응답이 없으면, 디바이스는 이것을 하나의 통신 실패로 카운트한다. 앱 개발자는 장치를 고아로 선언하기 전에 용인할 통신 실패 횟수를 결정한다.<br>
<br>
고아 장치의 NWK 계층은 MLME에 다음 절차 중 하나를 수행하도록 지시할 수 있다. <br>
1. 맥을 초기화하고 연결 절차 수행 <br>
2. 고아가 된 장치의 재편성 절차를 수행<br>
<br>
그림 3.18!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<br>
위 그림에서 재편성 절차는 디바이스가 고아 통지 명령을 코디네이터에게 보내는 것과 함께 시작된다. 코디네이터의 MLME는 고아가 된 디바이스의 존재를 MLME-ORPHAN.indication  primitive를 사용해서 네트워크 계층에게 통지한다. <br>
<br>
코디네이터의 네트워크 계층은 디바이스의 주소를 확인하고, 그 응답(MLME-ORPHAN.response 프리미티브를 사용)에서 네트워크 계층은 기기가 이전에 이 코디네이터와 관련되었는지 여부를 확인한다.<br>
<br>
만약 디바이스가 이 코디네이터와 이전에 연결되어 있었다면, 코디네이터의 MLME는 고아 디바이스에게 재할당명령을 보낸다. 그 재할당 명령들은 네트워크 설정값들을 전달하는데 사용된다. 명령이 성공적으로 고아 디바이스에게 전달되었을 때, MLME는 그 성공을 네트워크 계층에게 보고하기 위해 MLME-COMM-STATUS.indication 프리미티브를 사용한다.<br>
<br>
만약 디바이스가 이 코디네이터와 연결되어 있지 않았다면, 코디네이터의 MLME는 어떤 행동도 취하지 않는다. 고아 디바이스는 macResponseWaitTime 심볼동안 기다리고, 만약 어떤 재할당 명령도 오지 않는다면, 고아 디바이스는 그 범위내에 어떠한 코디네이터와도 연결되지 않았다고 가정한다.<br>

### 채널 스캐닝
채널 스캐닝 기능은 맥계층이 네트워크 계층에게 제공하는 서비스다. 채널 스캔은 디바이스의 POS(Personal Operating Space, 개인 운영 공간) 안의 활동에 관한 정보를 제공한다. 네가지 타입의 채널 스캔이 있다.<br>
1. ED 스캔. 각 채널의 에너지 레벨은 물리층 에너지 탐지 서비스를 사용해서 결정된다.<br>
2. 고아 스캔. 만약 디바이스가 고아가 됐다면, 현재 연결된 PAN을 검색할 수 있다. 고아 스캔에서 MLME는 고아 통지를 각 채널의 코디네이터에게 보내고, 코디네이터로부터 재할당 명령이 오기를 기다린다. 만약 디바이스가 재할당 명령을 받는다면, 그것은 수신기를 비활성화하여 스캐닝을 멈춘다. 그렇지 않으면 디바이스는 리스트에 있는 다음 채널에서 계쏙한다.<br>
3. active 스캔. 이 스캔에서, MLME는 먼저 비콘 요청 명령을 보낸다. 그리고 디바이스는 정보를 기록하기 위해 그것의 수신기를 활성화한다. 능동 스캔은 자체 네트워크를 구축하여 POS에서 다른 네트워크가 사용하는 모든 PAN 식별자를 발견하고, 자체 네트워크에 대해 고유한 PAN 식별자를 선택할 계획인 코디네이터가 사용할 수 있다. 능동 스캔 기능은 RFD에서 선택적이다.<br>
4. passive 스캔. 수동 스캔은 능동스캔과 대조적으로, 비콘 요청 명령 전송이 없다. MLME는 패시브 스캔 요청을 받은 즉시 수신기를 활성화하고 수신된 정보를 기록한다. 패시브 스캔은 비연결된 디바이스에 의해 연결 절차의 일부로 코디네이터를 찾기 위해 사용될 수 있다. <br>

### 비콘 notification
디바이스가 비콘을 수신할 때, MLME는 비콘에 페이로드가 있거나 자동요청 속성이 0으로 설정된 경우, 비콘 프레임에 포함된 매개변수를 네트워크 계층으로 전송해야 한다. 링크품질지수값과 비콘 프레임이 수신된 시간도 네트워크 층에게 전달된다. 비콘 통지를 수행하는 프리미티브는 MLME-BEACON-NOTIFY.indication이다.
<br>
### 코디네이터와 동기화
비콘 사용 네트워크에 있는 디바이스의 네트워크 계층은 MLME-SYNC.request 프리미티브를 사용해서 디바이스와 코디네이터를 동기화하도록 MLME를 요청할 수 있다. 디바이스는 딱 한번 혹은 연속적으로 비콘을 추적하도록 선택할 수 있다. 비콘 추적에서, 디바이스는 비콘의 예상 도착 시간 직전에 주기적으로 수신기를 작동시킨다. <br>
<br>
만약 디바이스와 코디네이터와 동기화를 잃으면, 네트워크 계층은 동기화의 상실에 대해 코디네이터에게 알리기 위해서 MLME-SYNC-LOSS.indication 프리미티브를 사용하여 MLME에 요청한다. 디바이스는 MaxLostBeacons(기본값이 4인 MAC 상수) 기간 동안 비콘을 수신하고, 비콘을 탐지하지 않으면 코디네이터와의 동기화를 상실했다고 결론짓는다.<br>
<br>
그림 3.19!!!!!!!!!!!!!!!!!!!!!!!!
<br>
위 그림에서 a의 경우는 디바이스가 비콘을 찾으려고 시도하지만 추적되지 않았을 때의 경우를 나타낸다. <br>
비콘 추적 시퀀스 차트는 b 경우와 같다.<br>

### 코디네이터로부터 데이터 요청 requesting data from coordinator
코디네이터는 주기적인 비콘 프레임 전송을 사용하여 네트워크 내의 디바이스에게 코디네이터에 대기 중인 그 디바이스를 위한 데이터가 있음을 통지할 수 있다. 디바이스가 보류중인 데이터에 관해 통지를 받았을 때, 디바이스의 네트워크 계층은 코디네이터에게 데이터 요청을 보내기 위해 MLME(MLME-POLL.request 프리미티브 사용)에 요청할 수 있다. 이 프리미티브는 비콘사용 비콘 비사용 네트워크 둘다 코디네이터로부터 데이터를 요청하기 위해 사용될 수 있다.<br>
<br>
디바이스는  macMaxFrameTotalWaitTime 심볼 기간동안 그것의 데이터를 기다린다. 만약 MLME가 이 기간동안 데이터를 받지 못하면, 그것의 네트워크 계층에게 MLME-POLL.confirm 을 사용해서 어떤 데이터도 받지 못한 것을 통지한다.<br>
<br>
그림 3.20!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
<br>
위 그림은 두개의 데이터 풀링 시나리오를 보여준다.<br>
첫번째 경우에서 디바이스는 데이터를 요청하고, 코디네이터는 보류된 프레임(frame pending)이 없다는 지시(FP=0)로 확인응답을 보낸다.<br>
두번째 경우로 보류된 프레임이 있으면(FP=1), 데이터가 확인응답뒤에 따라온다. 수신측 디바이스의 MLME는 맥 데이터 서비스의 MCPS-DATA.indication 프리미티브를 사용해서 그 데이터를 네트워크 계층으로 보낸다. <br>

