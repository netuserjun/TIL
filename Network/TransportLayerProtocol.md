## 전송층 프로토콜

### simple protocol
![image](https://user-images.githubusercontent.com/38284141/51536217-354def00-1e8e-11e9-9a31-0dd9dedafbd9.png)
송신측이 수신측을 고려하지 않고 무작정 보내는 비연결형 프로토콜. 흐름제어와 오류제어가 없다. 수신측이 수신패킷을 즉시 처리할 수 있다고 가정한다.<br>

### Stop and Wait protocol
흐름제어와 오류제어를 사용하는 연결지향 프로토콜. 송신측은 메시지를 보낸 후 확인응답이 오기 전까지 다음 패킷을 전송하지 않는다.<br>
패킷 훼손을 검사하기 위해 각 패킷에 checksum추가. 수신측은 이 검사합이 틀리면 통보없이 버린다. 그럼 ack이 안오니까 타이머가 끝난 송신측은 다시 보낸다.<br>
그래서 송신측은 ack이 도착하기 전까지 전송한 패킷의 사본을 가지고 있어야 한다. <br>
![image](https://user-images.githubusercontent.com/38284141/51536584-70045700-1e8f-11e9-8d22-fd3563541c94.png)
순서 번호라는 게 있는데 패킷에 x라는 순서번호가 붙었으면 다음 패킷의 순서번호는 x + 1이다. 그 다음 패킷은 x로 보내도 구분이 가능하므로 0과 1만 사용할
수 있는 것이다.<br>
수신측은 0번 패킷을 받고 1번 ack를 전송한다. 이 ack번호는 수신측이 다음으로 받기 기대하는 패킷 번호다. 그래서 송신측은 1번 패킷을 전송하고 수신측은 
0번 ack을 전송한다. 만약에 ack이 가다가 손실되면 송신측은 동일한 패킷을 다시 보내고 수신측은 중복 패킷이라는 사실을 알 수 있다.<br>
이 프로토콜은 대역폭이 큰 채널에서 비효율적이다. 또 파이프라인(멀티태스킹)이 불가능하다.

### 
