## 전송층 프로토콜

### simple protocol
![image](https://user-images.githubusercontent.com/38284141/51536217-354def00-1e8e-11e9-9a31-0dd9dedafbd9.png)
송신측이 수신측을 고려하지 않고 무작정 보내는 비연결형 프로토콜. 흐름제어와 오류제어가 없다. 수신측이 수신패킷을 즉시 처리할 수 있다고 가정한다.<br>

### Stop and Wait protocol
흐름제어와 오류제어를 사용하는 연결지향 프로토콜. 송신측은 메시지를 보낸 후 확인응답이 오기 전까지 다음 패킷을 전송하지 않는다.<br>
패킷 훼손을 검사하기 위해 각 패킷에 checksum추가. 수신측은 이 검사합이 틀리면 통보없이 버린다. 그럼 ack이 안오니까 타이머가 끝난 송신측은 다시 보낸다.<br>
그래서 송신측은 ack이 도착하기 전까지 전송한 패킷의 사본을 가지고 있어야 한다. <br>
![image](https://user-images.githubusercontent.com/38284141/51536584-70045700-1e8f-11e9-8d22-fd3563541c94.png)
순서 번호라는 게 있는데 패킷에 x라는 순서번호가 붙었으면 다음 패킷의 순서번호는 x + 1이다. 그 다음 패킷은 x로 보내도 구분이 가능하므로 0과 1만 사용할
수 있는 것이다.<br>
수신측은 0번 패킷을 받고 1번 ack를 전송한다. 이 ack번호는 수신측이 다음으로 받기 기대하는 패킷 번호다. 그래서 송신측은 1번 패킷을 전송하고 수신측은 
0번 ack을 전송한다. 만약에 ack이 가다가 손실되면 송신측은 동일한 패킷을 다시 보내고 수신측은 중복 패킷이라는 사실을 알 수 있다.<br>
이 프로토콜은 대역폭이 큰 채널에서 비효율적이다. 또 파이프라인(멀티태스킹)이 불가능하다.
![image](https://user-images.githubusercontent.com/38284141/51537151-21f05300-1e91-11e9-9295-ace173ee4ed2.png)
<br>
<br>
### Go-Back-N protocol
위 정지대기 프로토콜이 비효율적이기 때문에 채널 사용량을 늘리기 위해 사용한다. ack을 받기 전에 패킷 여러개를 전송하는 프로토콜이다.<br>
![image](https://user-images.githubusercontent.com/38284141/51537292-7693ce00-1e91-11e9-9ab9-52c6c8f44c99.png)
Sf는 미해결 패킷(ack을 못받은)중 가장 오래된 패킷 위치이고 Sn은 다음번에 보낼 패킷이다.<br>
ack번호는 누적된 값이다. ack이 6이면 5번까지의 패킷이 모두 잘 도착했다는 것을 의미한다.<br>
그림에서 왼쪽경우에는 ack이 모두 손실됐을 때 정상적으로 중복처리해서 패킷을 폐기하는 과정이고<br>
오른쪽 경우는 윈도우 크기때문에 뒷쪽 0이 아니라 앞쪽 0을 다시 보내서 문제가 생기는 것을 의미한다.<br>
그러니까 송신 윈도우 크기는 2^m보다 작아야 한다.<br>

### Selective-Repeat protocol
선택적 반복 프로토콜. GBN은 하나가 훼손되거나 훼손은 1도없지만 순서가 바뀌게 왔을 때 모든 패킷을 재전송해야한다. 네트워크 혼잡으로 패킷이 손실됐는데
손실때문에 재전송을 하면서 네트워크가 더 혼잡해지는 악순환이 생긴다. 그래서 SR, 선택적 반복은 이름에서 알 수 있듯이 손실된 패킷만 선택적으로 재전송한다.<br>
![image](https://user-images.githubusercontent.com/38284141/51542264-2ec77380-1e9e-11e9-9ffc-f8ccea20944e.png)
여기는 송신윈도우랑 수신윈도우가 있다. 송신윈도우는 최대 크기가 2^(m-1)이고 수신윈도우는 송신윈도우와 크기가 같다.<br>
SR에서는 ack이 의미하는 바가 GBN과 다르다. GBN에서 ack이 3이면 0,1,2를 잘 받았고 3을 달라는 말이지만 SR에서는 ack이 3이면 3번 패킷을 잘 받았다라는 말이다.<br>
![image](https://user-images.githubusercontent.com/38284141/51543869-eb6f0400-1ea1-11e9-8ef7-3cba83f12231.png)<br>
여기서 패킷 0,1,2,3을 보냈는데 1이 손실됐을 때 ack 0을 받으면 송신측 윈도우가 1만큼 전진하고, ack 1없이 2,3을 받으면 슬라이딩은 하지 않고 타임아웃까지 ack 1을 기다렸다가 끝내 안오면 패킷1을 다시 보낸다. 그리고 ack 1이 오면 3만큼 윈도우가 슬라이딩한다.

![image](https://user-images.githubusercontent.com/38284141/51544101-794aef00-1ea2-11e9-86c0-1d81e2022b04.png)
우측 경우 윈도우 크기가 2^(m-1)보다 크다. 이러면 뒷쪽 0번 패킷이 와야 할 순간에 앞쪽 0번 패킷이 다시 와서 문제가 생긴다.<br>

###  Bidirectional Protocols
위에 나온 프로토콜들은 한쪽은 전송만하고 다른 한쪽은 확인 응답만 하는 단방향 전송이다.<br>
하지만 실제로는 양쪽 방향 모두 전송과 응답을 해주는 양방향 전송을 사용한다.<br>
이 양방향 전송에서 피기배킹(piggybacking)을 사용하면 데이터 패킷에 확인응답을 함께 보내서 효율성을 증대시킬 수 있다.<br>
![image](https://user-images.githubusercontent.com/38284141/51544375-2160b800-1ea3-11e9-9083-a2fdf224d4fa.png)<br>
위 그림은 피기배킹을 이용한 GBN의 동작이다. 양 측이 각각 수신윈도우와 송신윈도우 2개의 독립적인 윈도를 갖는다.<br>


