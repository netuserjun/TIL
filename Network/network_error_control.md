# 네트워크의 오류검출과 정정

발신지에서 전송한 데이터는 수신지로 가는 길에 변경될수있다. 신뢰성 시스템은 이런 오류를 검출하고 정정할 수 있는 방법을 포함하고있다.<br>
오류를 검출하고 정정하는 중심 개념은 '중복'(redundancy)이다. 즉 보내는 측에서 데이터 이외에 추가 비트를 보내는 것이다. 이 비트들로 인해 수신자는 오류검출과 정정이 가능해진다.<br><br>
여기서 오류 검출이란 오류가 있나 없나를 확인하는 것이다. 몇 개의 오류인지도 상관없이 단순 유무만 따진다.<br><br>
오류 정정에서는 정확하게 어디서 몇 비트만큼 잘못되었는가를 알아야 한다. 그래서 검출에 비해 훨씬 어렵다.<br><br>

# 블록코딩

중복(redundancy)을 위해 사용하는 대표적인 방법이다. 코딩이란 어떤 둘 사이를 관련짓는것이다. 여기서는 실제데이터와 중복비트 사이를 관련짓는 것이다. 즉 블록코딩은 메시지를 블록단위로 쪼개서 각 블록에 중복 비트를 더하는 과정이다.<br><br>
메시지는 데이터워드(dataword)로 불리는 k비트의 블록으로 나뉜다. 이 각 블록들에 r개의 중복비트들을 더해서 길이가 n=k+r이 된다. 이 n비트 블록들을 코드워드(codeword)라고 부른다.<br><br>
![image](https://user-images.githubusercontent.com/38284141/50832534-db2f3300-1391-11e9-8bbf-ef06321b270c.png)<br>

여기서 동일한 데이터워드는 동일한 코드워드로 부호화된다. 즉 2^n - 2^k개의 코드워드는 사용되지 않는다는 것이다. 이 사용안된 코드는 무효 혹은 불법적인 것이다. 그런데 이 코드가 수신측에서 발견되면 이는 전송도중 변경되었다는 것이다.<br>
그래서 수신자가 코드워드를 받았을 때 유효 코드워드라면 데이터워드를 추출하고, 유효하지 않은 건 버려진다. 근데 여기서 유효코드가 전송중에 손상되서 다른 유효코드로 바뀐다면, 오류를 검출하지 못한다.

# 해밍 거리

오류 제어의 또다른 중요 개념이다. 원래는 한 문자열을 다른 문자열로 바꾸기 위해 몇 글자를 바꿔야 하는가를 나타내는 것이다. 통신에서 두 같은 크기의 워드 사이의 해밍거리는 서로 차이가 나는 해당 비트들의 개수다. 그러니까 발신한 코드워드가 00000이고 수신한 코드워드가 01101이라면 3개 비트에 오류가 발생한 것이니까 해밍거리는 3이다. 이 해밍거리가 중요한 이유는 이렇게 전송도중 발생한 오류비트들의 수를 알 수 있기 때문이다. 즉 해밍거리가 0이 아니면 오류가 발생한 것이다. 일반적으로 두 워드 X와 Y사이의 해밍거리를 d라고 표시한다.<br><br>

해밍거리는 두 워드에 XOR연산을 해서 결과로 얻은 값중에 1의 개수를 통해 쉽게 구할 수 있다.<br>
검출가능오류 개수는 해밍거리 - 1 이고 정정가능오류 개수는 (해밍거리 - 1)/2 이다.<br>
만약 s개의 오류를 검출하고 싶다면 해밍거리는 최소 s+1이어야한다. 손상된 채로 수신된 코드가 유효코드중의 하나가 될 수 없게 하기 위해서다.<br>

# 선형 블록 코드

오늘날 사용되는 대부분의 블록코드. 깊이 들어가면 선형대수학까지 알아야해서 간략하게 '두 유효한 코드워드를 XOR연산을 했을 때 다른 유효한 코드워드가 생성되는 코드'라고만 알아둔다.<br><br>
선형블록코드의 최소해밍거리는 0이 아닌 가장 적은 수의 1을 가지고 있는 코드워드의 1의 개수이다.<br><br>

선형블록코드 중에 패리티검사코드(parity check code)가 있다. k비트 데이터워드를 n = k + 1이 되도록 n비트 코드워드로 바꾸는 것이다.<br>
추가된 비트는 패리티 비트라고 불리며, 대체로 전체 코드워드의 1의 개수가 짝수가 되도록 선정된다.<br><br>

또다른 선형블록코드 중에 순환 코드(cyclic code)가 있다. 이 방식에서 코드워드를 순환시키면 다른 코드워드를 얻을 수 있다.<br>
즉 10011이라는 코드워드를 왼쪽으로 이동시켜서 얻은 00111도 코드워드이다. 원래 제일 앞에 있던 1이 뒤로 붙은거다.<br>
순환코드의 장점은 단일비트, 두 비트, 홀수 개의 비트 및 폭주 오류를 검출하는 데 우수하다. 또한 하드웨어, 소프트웨어로 구현이 쉽다.<br>

# 검사합

검사합은 메세지 길이와 무관하게 적용시킬 수 있는 오류검출기법이다. 대체로 네트워크층과 전송층에서 사용한다.<br>
발신지에서 메시지는 m비트의 유닛으로 나눠지고, 생성기에 의해 별도의 m비트 유닛을 생성하는데 이 별도의 유닛이 메세지와 함께 보내지는 검사합이다.<br>
목적지에서는 확인기가 메시지와 메시지의 검사합을 이용해서 새로운 검사합을 생성한다. 새로운 검사합이 모두 0일때만 메시지는 받아들여진다.<br>

![image](https://user-images.githubusercontent.com/38284141/50832552-eda96c80-1391-11e9-8382-0326ab9d7000.png)<br>

이해하기 쉽게 바꾸자면 보내려는 메시지가 (1,2,3)일때 생성기가 이들의 합 6을 메시지에 붙여서 (1,2,3,6)으로 보내지게된다. 받는 측에서는 (1,2,3,6)을 받고 검사합을 제외한 나머지 숫자 1,2,3을 더해서 6을 구한다음 받은 검사합과 비교해서 같은지 확인한다. 같으면 메시지가 변경없이 온 것이므로 받아들이고 다르다면 메시지를 버린다.<br>
다만 이 예처럼 합을 전송하는 것보다 1의 보수 연산을 통해 보수의 합을 보낸다면 훨씬 작업이 간단해진다.<br>

# 전향 오류 정정

위에서 본 오류검출과 재전송 기법은 실시간 멀티미디어 전송에서 적합하지 않다. 재전송을 기다릴 시간이 없는 것이다. 그래서 오류가 있다면 그 자리에서 정정해줄 필요가 있는데 이걸 전향오류정정(FEC,forward error correction)이라고 한다.<br>

동영상을 보낸다고 했을 때 각각의 패킷에 들어있는 고해상도 패킷에 이전 패킷의 저해상도 패킷을 결합해 보내는 방식이 있다. 그래서 패킷이 손상된다면 다음 패킷의 저해상도 패킷으로 영상을 복구해 낼 수 있다. 당연히 첫 패킷은 고해상도 뿐이다. 또한 마지막 패킷이 손실된다면 이건 복구할 수 없다. 이렇게 복구된 저해상도는 고해상도 사이에서 거의 알아 챌 수 없다.<br> 
![image](https://user-images.githubusercontent.com/38284141/50832583-02860000-1392-11e9-8d91-e4199de01b4d.png)<br>

이 문서의 사진 출처 : 데이터통신과 네트워킹 5판, Behrouz A.Forouzan, McGraw-Hill Education Korea



