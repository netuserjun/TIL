# 네트워크의 오류검출과 정정

발신지에서 전송한 데이터는 수신지로 가는 길에 변경될수있다. 신뢰성 시스템은 이런 오류를 검출하고 정정할 수 있는 방법을 포함하고있다.<br>
오류를 검출하고 정정하는 중심 개념은 '중복'(redundancy)이다. 즉 보내는 측에서 데이터 이외에 추가 비트를 보내는 것이다. 이 비트들로 인해 수신자는 오류검출과 정정이 가능해진다.<br><br>
여기서 오류 검출이란 오류가 있나 없나를 확인하는 것이다. 몇 개의 오류인지도 상관없이 단순 유무만 따진다.<br><br>
오류 정정에서는 정확하게 어디서 몇 비트만큼 잘못되었는가를 알아야 한다. 그래서 검출에 비해 훨씬 어렵다.<br><br>

# 블록코딩

중복(redundancy)을 위해 사용하는 대표적인 방법이다. 코딩이란 어떤 둘 사이를 관련짓는것이다. 여기서는 실제데이터와 중복비트 사이를 관련짓는 것이다. 즉 블록코딩은 메시지를 블록단위로 쪼개서 각 블록에 중복 비트를 더하는 과정이다.<br><br>
메시지는 데이터워드(dataword)로 불리는 k비트의 블록으로 나뉜다. 이 각 블록들에 r개의 중복비트들을 더해서 길이가 n=k+r이 된다. 이 n비트 블록들을 코드워드(codeword)라고 부른다.<br><br>
여기서 동일한 데이터워드는 동일한 코드워드로 부호화된다. 즉 2^n - 2^k개의 코드워드는 사용되지 않는다는 것이다. 이 사용안된 코드는 무효 혹은 불법적인 것이다. 그런데 이 코드가 수신측에서 발견되면 이는 전송도중 변경되었다는 것이다.<br>
그래서 수신자가 코드워드를 받았을 때 유효 코드워드라면 데이터워드를 추출하고, 유효하지 않은 건 버려진다. 근데 여기서 유효코드가 전송중에 손상되서 다른 유효코드로 바뀐다면, 오류를 검출하지 못한다.

# 해밍 거리

오류 제어의 또다른 중요 개념이다. 원래는 한 문자열을 다른 문자열로 바꾸기 위해 몇 글자를 바꿔야 하는가를 나타내는 것이다. 통신에서 두 같은 크기의 워드 사이의 해밍거리는 서로 차이가 나는 해당 비트들의 개수다. 그러니까 발신한 코드워드가 00000이고 수신한 코드워드가 01101이라면 3개 비트에 오류가 발생한 것이니까 해밍거리는 3이다. 이 해밍거리가 중요한 이유는 이렇게 전송도중 발생한 오류비트들의 수를 알 수 있기 때문이다. 즉 해밍거리가 0이 아니면 오류가 발생한 것이다. 일반적으로 두 워드 X와 Y사이의 해밍거리를 d라고 표시한다.<br><br>

해밍거리는 두 워드에 XOR연산을 해서 결과로 얻은 값중에 1의 개수를 통해 쉽게 구할 수 있다.<br>
검출가능오류 개수는 해밍거리 - 1 이고 정정가능오류 개수는 (해밍거리 - 1)/2 이다.<br>
만약 s개의 오류를 검출하고 싶다면 해밍거리는 최소 s+1이어야한다. 손상된 채로 수신된 코드가 유효코드중의 하나가 될 수 없게 하기 위해서다.<br>

# 선형 블록 코드

오늘날 사용되는 대부분의 블록코드. 깊이 들어가면 선형대수학까지 알아야해서 간략하게 '두 유효한 코드워드를 XOR연산을 했을 때 다른 유효한 코드워드가 생성되는 코드'라고만 알아둔다.<br><br>
선형블록코드의 최소해밍거리는 0이 아닌 가장 적은 수의 1을 가지고 있는 코드워드의 1의 개수이다.<br><br>

