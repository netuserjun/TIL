## AVR
8비트 마이크로프로세서. 32개 8비트 레지스터 내장. <br>
LDI R0,2 : 레지스터 R0에 2 저장 <br>
ADD R0,R1 : 레지스터 R0과 R1의 값을 더해서 R0에 저장 <br>
SUB R0,R1 : 레지스터 R0의 값에서 R1의 값을 빼서 R0에 저장 <br>
INC R0 : 레지스터 R0값을 1 증가.<br>

### 분기명령어

CP R0,R1 : 둘 값을 비교 <br>
CPI R0, 4 : 상수와 비교하는 경우 <br>
BRGE 1 : R0이 R1보다 크거나 같은 경우 1줄 건너뛰고 실행 <br>
BRLT 1 : R0이 R1보다 작은 경우 1줄 건너뛰고 실행 <br>
BREQ 1 : R0이 R1과 같은 경우 1줄 건너뛰고 실행 <br>
BRNE 1 : R0이 R1과 다른 경우 1줄 건너뛰고 실행 <br>
RJMP -2 : 바로 위 문장으로 점프 <br>
<br>

### 메모리 명령어
레지스터가 방안의 책장이라면 메모리는 도서관이다. 마이크로프로세서 밖에 위치해서 저장공간은 많지만 왓다갔다 시간이 오래걸린다. <br>
그래서 메모리에 있는 값을 가져와서 레지스터에 임시저장(Load)하고 연산을 한 뒤 결과를 메모리로 저장(Store)하는 과정을 거친다.<br>
메모리에도 공간마다 주소라고 부르는 번호가 있다.<br>
메모리에 값을 바로 때려박을 수는 없고 레지스터에서 불러오는 식으로 저장을 해야한다.<br>
그러니까 메모리 100번지에 3을 넣고 싶으면 LDI R0,3 이렇게 R0레지스터에 3을 박고, <br> 
STS 100, R0 이렇게 100번지 메모리에 레지스터 R0의 값을 저장하는 식이다. <br>
<br>
메모리에 저장된 값을 불러오려면 LDS R0,100으로 100번지에 저장된 값을 레지스터 R0에 불러온다.<br>
<br>

### 레지스터 묶기
레지스터에 값을 저장하려는데 값이 257이다.<br>
이러면 8비트 레지스터 하나에 저장할 수 없으니까 레지스터 2개(R0,R1)를 묶는다.<br>
그러면 ( 0000 0001 )( 0000 0001) 로 저장이 된다. <br>
즉 실제로 저장된 값은 R0과 R1 모두 1이지만 257로 취급한다. <br>
따라서 LDI R0,1      LDI R1,1 이다. <br>
515는  ( 0000 0010 )( 0000 0011) 이런식으로     LDI R3,2     LDI R2,3   이렇게 한다. <br>
두 경우 모두 R1, R3이 상위바이트, 나머지가 하위바이트라고 한다.<br>
<br>
자 그럼 이 두 값 257과 515를 덧셈을 하려면 어떻게 할까.<br>
간단하게는 상위바이트는 상위바이트끼리 하위바이트는 하위바이트끼리 더하면 된다.<br>
즉 ADD R2,R0과 ADD R3, R1을 하면 된다.<br>
하지만 257과 511같은 경우




