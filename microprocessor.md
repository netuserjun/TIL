## AVR
8비트 마이크로프로세서. 32개 8비트 레지스터 내장. <br>
LDI R0,2 : 레지스터 R0에 2 저장 <br>
ADD R0,R1 : 레지스터 R0과 R1의 값을 더해서 R0에 저장 <br>
SUB R0,R1 : 레지스터 R0의 값에서 R1의 값을 빼서 R0에 저장 <br>
INC R0 : 레지스터 R0값을 1 증가.<br>

### 분기명령어

CP R0,R1 : 둘 값을 비교 <br>
CPI R0, 4 : 상수와 비교하는 경우 <br>
BRGE 1 : R0이 R1보다 크거나 같은 경우 1줄 건너뛰고 실행 <br>
BRLT 1 : R0이 R1보다 작은 경우 1줄 건너뛰고 실행 <br>
BREQ 1 : R0이 R1과 같은 경우 1줄 건너뛰고 실행 <br>
BRNE 1 : R0이 R1과 다른 경우 1줄 건너뛰고 실행 <br>
RJMP -2 : 바로 위 문장으로 점프 <br>
<br>

### 메모리 명령어
레지스터가 방안의 책장이라면 메모리는 도서관이다. 마이크로프로세서 밖에 위치해서 저장공간은 많지만 왓다갔다 시간이 오래걸린다. <br>
그래서 메모리에 있는 값을 가져와서 레지스터에 임시저장(Load)하고 연산을 한 뒤 결과를 메모리로 저장(Store)하는 과정을 거친다.<br>
메모리에도 공간마다 주소라고 부르는 번호가 있다.<br>
메모리에 값을 바로 때려박을 수는 없고 레지스터에서 불러오는 식으로 저장을 해야한다.<br>
그러니까 메모리 100번지에 3을 넣고 싶으면 LDI R0,3 이렇게 R0레지스터에 3을 박고, <br> 
STS 100, R0 이렇게 100번지 메모리에 레지스터 R0의 값을 저장하는 식이다. <br>
<br>
메모리에 저장된 값을 불러오려면 LDS R0,100으로 100번지에 저장된 값을 레지스터 R0에 불러온다.<br>
<br>

### 레지스터 묶기
레지스터에 값을 저장하려는데 값이 257이다.<br>
이러면 8비트 레지스터 하나에 저장할 수 없으니까 레지스터 2개(R0,R1)를 묶는다.<br>
그러면 ( 0000 0001 )( 0000 0001) 로 저장이 된다. <br>
즉 실제로 저장된 값은 R0과 R1 모두 1이지만 257로 취급한다. <br>
따라서 LDI R0,1      LDI R1,1 이다. <br>
515는  ( 0000 0010 )( 0000 0011) 이런식으로     LDI R3,2     LDI R2,3   이렇게 한다. <br>
두 경우 모두 R1, R3이 상위바이트, 나머지가 하위바이트라고 한다.<br>
<br>
자 그럼 이 두 값 257과 515를 덧셈을 하려면 어떻게 할까.<br>
간단하게는 상위바이트는 상위바이트끼리 하위바이트는 하위바이트끼리 더하면 된다.<br>
즉 ADD R2,R0과 ADD R3, R1을 하면 된다.<br>
하지만 257과 511같은 경우 ( 0000 0001 )( 0000 0001)과 ( 0000 0001 )( 1111 1111)이므로 R0에 FF가 저장된다. <br>
이 상태로 단순히 하위 바이트들끼리 덧셈을 하면 (0000 0000)이 되면서 R2에 00이 들어가버린다. <br>
따라서 이 오버플로우로 생기는 carry값을 어딘가에 저장을 하고 이용해야 한다. <br>
다만 캐리값 저장은 마이크로프로세서가 알아서 해주니까 이용만 잘 하면 된다.<br>
이용하는 방법은 바이트끼리 짝지어 덧셈을 할때 ADD가 아닌 ADC를 사용하는 것이다. <br>
뺄셈의 경우는 SBC를 사용.<br>

### 기계어
ADD R3,R2라고 코딩을 하더라도 이걸 기계가 알아먹을수는 없다. AVR이라는건 결국 논리회로 덩어리기계이므로 0과 1로 바꿔져서 AVR로 들어가게 된다. <br>
이 바뀌는 규칙이 있는데 ADD Rd,Rr을 기계어로 바꾸려면 다음과 같은 규칙을 따른다.<br>
#### 0000 11rd dddd rrrr
이대로 ADD R3, R2를 바꿔보면 <br>
R3은 다섯비트로 00011, R2는 00010이니까 이게 각각 ddddd, rrrrr이다.<br>
따라서 0000 1100 0011 0010이라는 기계어가 실제로 AVR에 들어간다. <br>
표현할때는 간단하게 16진수로 0C32 <br>
<br>
LDI Rd, k(상수)를 기계어로 바꾸는 규칙은 아래와 같다.<br>
#### 1110 kkkk dddd kkkk
여기서 그런데 d를 보면 비트가 4개다. 그럼 표현할 수 있는 가짓수는 16개. 그런데 레지스터는 32개다. <br>
그래서 조건이 붙는다. 이때 레지스터는 16번이상 31번 이하다. R0은 못온다는 이야기.<br>
16번 이상이라는 말은 2진수로 바꿨을때 가장 큰 자릿수가 무조건 1이니까, 그 1은 제외하고 뒤 4자리를 dddd로 사용하면 된다.<br>
또한 상수값은 8개 비트로 사용되므로 0이상 255이하만 k가 될 수 있다.<br>
저 위에서 했던 예시들은 다 문법에 맞지않는다(...)<br>
그래서 올바른 예시로 LDI R17, 5를 바꿔보면 <br>
17은 10001이므로 0001이 dddd, 5는 0000 0101로 kkkk kkkk자리에 넣어서 <br>
1110 0000 0001 0101 이 실제 AVR로 들어가는 기계어다. <br>
16진수로는 E015.<br>
<br>
BRGE K 규칙은<br>
#### 1111 01kk kkkk k100
BRGE 1은 1111 0100 0000 1100이다. (F40C) <br>
<br>
<br>
다만 이런 과정은 모두 어셈블러가 대신 해주기때문에 직접 할 필요는 없다. <br>
<br>
이 기계어는 마이크로프로세서의 메모리로 올라간다.(이 메모리는 내장?) <br>
마이크로프로세서는 메모리에 있는 코드를 가져오고 해석한뒤 실행한다. <br>
그리고 그 다음번지에 저장된 코드를 가져와서 해석하고 실행하는 동작을 계속한다.<br>
이렇게 동작하기 위해서는 마이크로프로세서가 자신이 어디까지 읽었는지 기억하고 있어야 다음에 읽을 코드위치를 알 수 있다.<br>
이렇게 다음으로 실행할 코드가 어딨는지 알려주는게 마이크로프로세서 내부에 있는 PC(program counter)이다. <br>
PC의 초기값은 0이고, 이 값을 주소로 삼아서 읽어오는 것이다. <br>
읽어서 실행하고 나면 PC값을 하나 증가시키는 과정을 반복한다. <br>
<br>
그런데 PC가 항상 1씩 증가하는건 아니다. <br>
분기명령을 만났을 때는 감소할 수도 증가할 수도 있다. <br>
<br>
예를 들어 BRGE 1의 경우에 PC값은 조건에 맞으면 PC + k + 1 이고, 조건에 맞지 않으면 PC + 1이다.<br>
즉 조건에 맞지 않으면 그냥 원래대로 1증가 하는거고, 조건에 맞다면 BRGE 뒤에 붙은 k에 따라 달라지는 것이다. <br>

### ISA(instruction Set architecture) 명령어 집합 구조
instruction set + memory structure + resgister set <br>
이점 : 소프트웨어 개발자가 내부구조에 대해 알 필요가 없다. , 하드웨어 개발자는 어떤 소프트웨어를 만들든 명령어 집합 구조만 만족시키면 된다. 인텔프로세서처럼 하위버전과 같은 구조라면 프로그램이 그대로 구동가능하다. <br>
instruction register : 프로그램 메모리에서 읽어온 명령어를 실행하기 위해 저장하는 곳(16비트 공간)


요즘 C나 c++로 코딩을 한다는데 우리가 하는거는 언어가 뭐지 : 실제로 할 때는 C언어 아트맬스튜디오 로우레벨은 과제에서 안다루고..<br>
메모리(RAM일까) 위치. 크기. : 내부메모리 d램 32kb 프로그램이 들어가는. , 캐쉬..<br>
IR(instruction register)와 그냥 레지스터의 차이 : 컴퓨터구조 설계. RISC CISC 차이점.<br>
ADC : ADD를 꼭 더하기에만 쓰는 건 아니니까.<br>
심전도 측정과 전송과정 : <br>



