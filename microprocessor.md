## AVR
8비트 마이크로프로세서. 32개 8비트 레지스터 내장. <br>
LDI R0,2 : 레지스터 R0에 2 저장 <br>
ADD R0,R1 : 레지스터 R0과 R1의 값을 더해서 R0에 저장 <br>
SUB R0,R1 : 레지스터 R0의 값에서 R1의 값을 빼서 R0에 저장 <br>
INC R0 : 레지스터 R0값을 1 증가.<br>

### 분기명령어

CP R0,R1 : 둘 값을 비교 <br>
CPI R0, 4 : 상수와 비교하는 경우 <br>
BRGE 1 : R0이 R1보다 크거나 같은 경우 1줄 건너뛰고 실행 <br>
BRLT 1 : R0이 R1보다 작은 경우 1줄 건너뛰고 실행 <br>
BREQ 1 : R0이 R1과 같은 경우 1줄 건너뛰고 실행 <br>
BRNE 1 : R0이 R1과 다른 경우 1줄 건너뛰고 실행 <br>
RJMP -2 : 바로 위 문장으로 점프 <br>
<br>

### 메모리 명령어
레지스터가 방안의 책장이라면 메모리는 도서관이다. 마이크로프로세서 밖에 위치해서 저장공간은 많지만 왓다갔다 시간이 오래걸린다. <br>
그래서 메모리에 있는 값을 가져와서 레지스터에 임시저장(Load)하고 연산을 한 뒤 결과를 메모리로 저장(Store)하는 과정을 거친다.<br>
메모리에도 공간마다 주소라고 부르는 번호가 있다.<br>
메모리에 값을 바로 때려박을 수는 없고 레지스터에서 불러오는 식으로 저장을 해야한다.<br>
그러니까 메모리 100번지에 3을 넣고 싶으면 LDI R0,3 이렇게 R0레지스터에 3을 박고, <br> 
STS 100, R0 이렇게 100번지 메모리에 레지스터 R0의 값을 저장하는 식이다. <br>
<br>
메모리에 저장된 값을 불러오려면 LDS R0,100으로 100번지에 저장된 값을 레지스터 R0에 불러온다.<br>
<br>

### 레지스터 묶기
레지스터에 값을 저장하려는데 값이 257이다.<br>
이러면 8비트 레지스터 하나에 저장할 수 없으니까 레지스터 2개(R0,R1)를 묶는다.<br>
그러면 ( 0000 0001 )( 0000 0001) 로 저장이 된다. <br>
즉 실제로 저장된 값은 R0과 R1 모두 1이지만 257로 취급한다. <br>
따라서 LDI R0,1      LDI R1,1 이다. <br>
515는  ( 0000 0010 )( 0000 0011) 이런식으로     LDI R3,2     LDI R2,3   이렇게 한다. <br>
두 경우 모두 R1, R3이 상위바이트, 나머지가 하위바이트라고 한다.<br>
<br>
자 그럼 이 두 값 257과 515를 덧셈을 하려면 어떻게 할까.<br>
간단하게는 상위바이트는 상위바이트끼리 하위바이트는 하위바이트끼리 더하면 된다.<br>
즉 ADD R2,R0과 ADD R3, R1을 하면 된다.<br>
하지만 257과 511같은 경우 ( 0000 0001 )( 0000 0001)과 ( 0000 0001 )( 1111 1111)이므로 R0에 FF가 저장된다. <br>
이 상태로 단순히 하위 바이트들끼리 덧셈을 하면 (0000 0000)이 되면서 R2에 00이 들어가버린다. <br>
따라서 이 오버플로우로 생기는 carry값을 어딘가에 저장을 하고 이용해야 한다. <br>
다만 캐리값 저장은 마이크로프로세서가 알아서 해주니까 이용만 잘 하면 된다.<br>
이용하는 방법은 바이트끼리 짝지어 덧셈을 할때 ADD가 아닌 ADC를 사용하는 것이다. <br>
뺄셈의 경우는 SBC를 사용.<br>

### 기계어
ADD R3,R2라고 코딩을 하더라도 이걸 기계가 알아먹을수는 없다. AVR이라는건 결국 논리회로 덩어리기계이므로 0과 1로 바꿔져서 AVR로 들어가게 된다. <br>
이 바뀌는 규칙이 있는데 ADD Rd,Rr을 기계어로 바꾸려면 다음과 같은 규칙을 따른다.<br>
#### 0000 11rd dddd rrrr
이대로 ADD R3, R2를 바꿔보면 <br>
R3은 다섯비트로 00011, R2는 00010이니까 이게 각각 ddddd, rrrrr이다.<br>
따라서 0000 1100 0011 0010이라는 기계어가 실제로 AVR에 들어간다. <br>
표현할때는 간단하게 16진수로 0C32 <br>
<br>
LDI Rd, k(상수)를 기계어로 바꾸는 규칙은 아래와 같다.<br>
#### 1110 kkkk dddd kkkk
여기서 그런데 d를 보면 비트가 4개다. 그럼 표현할 수 있는 가짓수는 16개. 그런데 레지스터는 32개다. <br>
그래서 조건이 붙는다. 이때 레지스터는 16번이상 31번 이하다. R0은 못온다는 이야기.<br>
16번 이상이라는 말은 2진수로 바꿨을때 가장 큰 자릿수가 무조건 1이니까, 그 1은 제외하고 뒤 4자리를 dddd로 사용하면 된다.<br>
또한 상수값은 8개 비트로 사용되므로 0이상 255이하만 k가 될 수 있다.<br>
저 위에서 했던 예시들은 다 문법에 맞지않는다(...)<br>
그래서 올바른 예시로 LDI R17, 5를 바꿔보면 <br>
17은 10001이므로 0001이 dddd, 5는 0000 0101로 kkkk kkkk자리에 넣어서 <br>
1110 0000 0001 0101 이 실제 AVR로 들어가는 기계어다. <br>
16진수로는 E015.<br>
<br>
BRGE K 규칙은<br>
#### 1111 01kk kkkk k100
BRGE 1은 1111 0100 0000 1100이다. (F40C) <br>
<br>
<br>
다만 이런 과정은 모두 어셈블러가 대신 해주기때문에 직접 할 필요는 없다. <br>
<br>
이 기계어는 마이크로프로세서의 메모리로 올라간다.(이 메모리는 내장?) <br>
마이크로프로세서는 메모리에 있는 코드를 가져오고 해석한뒤 실행한다. <br>
그리고 그 다음번지에 저장된 코드를 가져와서 해석하고 실행하는 동작을 계속한다.<br>
이렇게 동작하기 위해서는 마이크로프로세서가 자신이 어디까지 읽었는지 기억하고 있어야 다음에 읽을 코드위치를 알 수 있다.<br>
이렇게 다음으로 실행할 코드가 어딨는지 알려주는게 마이크로프로세서 내부에 있는 PC(program counter)이다. <br>
PC의 초기값은 0이고, 이 값을 주소로 삼아서 읽어오는 것이다. <br>
읽어서 실행하고 나면 PC값을 하나 증가시키는 과정을 반복한다. <br>
<br>
그런데 PC가 항상 1씩 증가하는건 아니다. <br>
분기명령을 만났을 때는 감소할 수도 증가할 수도 있다. <br>
<br>
예를 들어 BRGE 1의 경우에 PC값은 조건에 맞으면 PC + k + 1 이고, 조건에 맞지 않으면 PC + 1이다.<br>
즉 조건에 맞지 않으면 그냥 원래대로 1증가 하는거고, 조건에 맞다면 BRGE 뒤에 붙은 k에 따라 달라지는 것이다. <br>

### ISA(instruction Set architecture) 명령어 집합 구조
instruction set + memory structure + resgister set <br>
이점 : 소프트웨어 개발자가 내부구조에 대해 알 필요가 없다. , 하드웨어 개발자는 어떤 소프트웨어를 만들든 명령어 집합 구조만 만족시키면 된다. 인텔프로세서처럼 하위버전과 같은 구조라면 프로그램이 그대로 구동가능하다. <br>
instruction register : 프로그램 메모리에서 읽어온 명령어를 실행하기 위해 저장하는 곳(16비트 공간) <br>
IR이 MUX(멀티플랙서, 모든레지스터의 한개 비트와 연결)와 연결되어 어떤 레지스터가 연결될지를 제어한다.<br>
<br>
### 크기비교
크기비교(CP)의 결과는 SREG(status 레지스터, 8비트ITHSVNZC)라는 레지스터 내부의 VNZC에 저장됨.<br>
크기 비교는 기본적으로 비교할 두 값을 빼서 판단한다. <br>
a-b를 했을때 음수면 a가 작은 것이므로 N(Negative) 비트 부분이 1로 표시 Z(Zero)는 같음을 나타내는 것이므로 0으로 표시 <br> 
<br>
V는 overflow를 나타내는데 결과가 8비트를 넘은 경우다. <br>
a가 127이고 b가 -2라면 a가 b보다 큰건데 두개를 빼면 0111 1111 - 1111 1110이니까 덧셈으로 바꿔서 0111 1111 + 0000 0001에 뒤에 캐리 1추가. <br>
계산하면 1000 0001이 나온다. <br>
제일 앞에 비트가 1이니까 음수로 처리된다. 그래서 -127로 해석되서 N비트가 1로 셋팅이 된다. <br>
8비트로 표현할 수 있는 수는 -128부터 127까지인데 결과가 129니까 엉뚱한 수인 -127이 나온것이다. <br>
이럴 때를 대비해서 V비트가 있다. <br>
위의 경우에 N비트와 V비트가 1이 되서 단순히 N만 보고 판단하지 않고 V와 함께 판단한다. <br>

## GPIO control
General purpose input output. 목적이 정해지지 않고 일반적인 목적(범용, 다목적) 입출력.<br>
마이크로프로세서는 핀을 통해 입출력을 한다. <br>
입력은 전압에 따라 동작하는 것이고, 출력은 이 전압을 유지시키는 것이다. <br>
drive한다. : 전압을 바꿀 수 있다. <br>
1개의 핀으로 1비트의 정보를 전달할 수 있다. <br>
ATmega128은 64개의 핀이 있다. <br>
핀들은 전력핀과 신호핀으로 분류할 수 있다.
전력핀은 전원을 공급해주는데 총 6개가 있고 5V(VDD VCC) 0V(기준전압,VSS GND) 등으로 표기되어있다. <br>
나머지는 신호핀인데 신호핀은 특수목적핀과 다목적핀으로 구분된다. <br>
특수목적핀은 총 5개로 하드웨어적으로 목적이 고정되어 있다. 예를 들면 오직 리셋 기능만 하는 리셋핀이 있다.<br>
다목적핀은 나머지 53개로 사용자가 원하는 목적대로 제어를 할 수 있다. <br>
<br>
다목적핀을 어떻게 다룰 것인가.<br>
53개를 동시에 쓸 수는 없고 AVR은 8비트 단위로 움직이므로 8비트 그룹이 필요하다. <br>
A~G그룹이 존재한다. PA0 ~ PA7, ... , PG0 ~ PG7 까지<br>
고려사항 첫번째는 방향설정(입력인가 출력인가), 방향을 정했다면 출력의 경우엔 출력값을 지정해줘야 한다. 입력의 경우에는 입력값을 읽어올 수 있어야한다. <br>
<br>
#### 방향설정
방향설정에는 레지스터가 필요하다. 입력인지 출력인지를 정했으면 그걸 저장해야 하기 떄문이다. 핀 묶음이 8개이므로 8비트짜리 레지스터에 다 저장가능하다. 이때 사용하는 레지스터가 DDR 레지스터인데 PA의 경우 DDRA를 사용해서 정보를 저장한다. PB핀은 DDRB레지스터 이런 식이다.  저장 방식은 DDRA의 경우 0번 비트가 PA0 핀의 방향을 저장하는데, 입력으로 사용하는 경우 0, 출력으로 사용하는 경우 1로 셋팅된다. <br>
<br>
그럼 이 DDRA라는 레지스터에 값을 어떻게 저장해야할까 <br>
memory mapped I/O. <br>
AVR의 메모리 주소는 16비트다. 16비트로 표현할 수 있는 가짓수는 65535개. 0x0000부터 0xffff까지.<br>
재밌는건 0x0000은 R0의 주소다. 레지스터들에 주소가 할당이 되어있어서 비효율적이지만 이 주소를 사용하여 레지스터에 값을 넣을 수도 있다. <br>
메모리중에는 이런 레지스터들을 위해 할당된 공간도 있다.<br>
LDI R16, 3 <br>
STS 0x003A , R16 이라고 하면 <br>
해당 주소가 가리키는 DDRA 레지스터에 00000011이 저장된다. <br>
c언어 코드 : *((char *) OxOO3A) = 3 <br>
<br>*
#### 출력값 지정
8비트 레지스터인 PORTA를 이용한다. 이 레지스터의 주소는 0x003B다. <br>
이 레지스터의 각 비트의 값은 PA0 ~ PA7의 출력되는 값이다. <br>
0이면 0V, 1이면 5V가 나간다는 말이다. <br>
LDI R16, OxFF <br>
STS 0x003A , R16  // PA 모두 출력으로 사용하겠다.<br>
LDI R16, Ox36 <br>
STS 0x003B , R16 <br>
이렇게 하면 PORTA 레지스터에 0011 0110이 저장된다. <br>
차례대로 PA7은 0볼트, ... , PA1 5볼트, PA0은 0볼트가 출력값으로 지정된다.  <br>
<br>
#### 입력값 읽어오기
뭘 읽어올지 지정을 해야한다. <br>
0x0039 번지의 PINA 레지스터가 있다. <br>
LDS R16, 0x0039를 하면 이 주소에 해당하는 PINA, 즉 PA0부터 PA7까지 들어오고있는 입력값을 읽어서 R16에 저장한다. <br>
입력값이 0V 이면 0으로, 5V라면 1로 저장한다. <br>
<br>

## 인터럽트
하던 작업을 멈추고 이 작업(ISR, interrupt service routine)을 해달라고 하드웨어적으로 요청하는 것.<br>
인터럽트 발생원으로는 reset, timer, INT 등등 50가지가 넘게 있다. <br>
ISR 위치는 프로그램 메모리의 정해진 위치에 들어간다. INT0의 경우 0002번지에 해야할 일이 있고, TIMER 1 CAPT는 0016번지에 작업이 있다.<br>
mask enable/disable 은 다양한 인터럽트에 대한 반응을 결정한다. 즉 프로그래머가 특정 인터럽트를 무시하려면 disable로 하면 된다. <br>
인터럽트를 처리하겠다 하면 enable이라고 한다. 이런 과정은 각 인터럽트마다 정해진 레지스터에 값을 셋팅함으로써 결정할수있다.<br>
<br>

#### 폴링(polling)방식
외부에서 어떤값이 들어오는지를 계속 관찰하는것. 사용자가 명령어를 사용하여 입력값을 계속 읽어 변화를 알아내는 방식 <br>
외부에서 입력이 자주 들어와서 반응을 자주 해줘야할 때 사용 <br>
#### 인터럽트
MCU 자체가 하드웨어적으로 신호가 들어오면 그 변화를 체크하여 일정한 동작을 하는 방식. <br>
외부 입력이 별로 없을 때 사용 <br>

### Global interrupt enable
모든 인터럽트에 대해 작업을 받을지 안받을지를 한꺼번에 지정하는 기능이 있다. 위에서 나온 SREG의 최상위 비트인 I를 0으로 하면 어떤 인터럽트든 무시하고, 1이면 인터럽트들 중에 enable로 설정된 인터럽트만 받아들인다.<br>
<br>

### external interrupt 외부 인터럽트
외부 인터럽트는 마이크로프로세서마다 다르긴 하지만 ATmega128의 경우에는 GPIO를 통해 들어온다. <br>
전압이 몇 V여야 인터럽트 신호인가? ATmega128에는 외부 인터럽트에 3가지 모드가 있다. <br>
0V, 0V에서5V(rising edge), 5V에서0V(falling edge) <br> 
EICRA 레지스터(8비트)는 8개 비트를 2비트씩 4묶음으로 묶어서 어떤 인터럽트인지 나타낸다. 0,1비트묶음은 INT0, 6,7비트묶음은 INT3을 나타낸다. <br>
이 비트들마다 정해진 규칙에 따라 해당 비트들이 1또는 0으로 지정됨으로써 어떤 모드인지도 나타낸다. <br>
두번째 묶음인 2,3비트묶음이 1,0이라면 falling edge를 뜻한다. 즉 INT1 인터럽트가 5V에서 0V로 떨어질때 걸린다. <br>
<br>
역시 각 인터럽트마다 enable, disable을 할 수 있는데, EIMSK(External Interrupt MASK register)라는 레지스터를 이용해서 INT0부터 INT7까지를 지정할 수 있다. <br>
각 비트의 1은 enable, 0은 disable을 뜻한다. <br>
스위치를 누를때 인터럽트가 발생한다 > 전압이 들어올때 > rising edge > 11 <br>

PD0,1,2,3  PE4,5,6,7 핀을 통해 8종류의 외부 인터럽트를 받아들인다. <br>
이 인터럽트들이 오는 경로에 EIMSK가 스위치 형태로 달려있는데 열리면 무시 닫히면 받아들이는 식으로 작동한다. <br>
모든 EIMSK 스위치들은 하나의 SREG 스위치에 OR게이트로 연결된다. SREG의 7번 비트 설정을 통해 최종적으로 인터럽트들의 승인을 제어할 수 있다. <br>
<br>
벡터형 인터럽트 : ISR이 인터럽트마다 다 다른곳에 있어서 인터럽트가 걸리면 해당하는 곳으로 보내주는것 <br>
조사형 인터럽트 : ISR이 오직 하나만 있어서 무조건 한 곳에서만 작업하지만 소프트웨어적으로 무슨일을 하는지 처리해주는것 <br>
<br>
인터럽트 우선순위 : reset이 최상위 <br> 
<br>
외부 인터럽트 트리거 : 이때가 인터럽트다. <br>
edge 트리거 : 하강과 상승엣지 트리거가 있고, 전압이 변하는 순간을 트리거로 인식 <br>
level 트리거 : 특정 전압 0또는 5일때 트리거로 인식. 가끔 전압이 튀는 경우가 있으므로 일정시간이상 유지되야 인식함. <br>
EICRA,B : External Interrupt Control Register A,B. 언제가 외부 인터럽트의 트리거인지를 설정하는 레지스터. 2개 비트씩 짝을 지어 0~3번의 트리거 설정. B는 4~7설정<br>
EIFR : External Interrupt Flag Register, 엣지 트리거 방식일때 엣지순간에 해당 인터럽트 처리를 못해주는 경우를 대비해서, 엣지가 발생한 사실을 엣지 디택터가 확인하고 하드웨어적으로 여기에 1이라는 값을 저장을 해둔다. 그리고 1을 계속해서 보내면서 알린다. 8개 비트이므로 각 비트마다 INT0~7의 엣지 발생 사실을 저장한다. 다시 0으로 만들때는 해당 비트에 1을 쓰면 0이 된다?<br>

## 타이머 
카운터와 비슷하지만 약간 개념이 다름. 하드웨어적으로는 똑같은 구조를 가짐. ATmega128에는 합쳐서 4개(0,1,2,3) 존재. <br>
시간 측정 방법 : clock 신호를 단위로 측정. clock은 0과 1을 교대로 보내는 일정한 신호. 클락이 몇번 들어왔는지 센다. <br>
알림 기능 방법 : 설정시간이 되면 마이크로프로세서에게 인터럽트를 건다. <br>
#### 클락을 측정하는 하드웨어의 구조
클락을 세기 위해서는 레지스터(TCNT0, 8비트)가 필요하다. 레지스터에 저장된 값을 클락 1개가 들어올 때마다 1씩 증가시키므로 0부터 255까지.<br>
그리고 255에서 0으로 갈때 인터럽트(TOV)를 걸어준다. <br>
<br>
타이머 모드에는 세 가지가 있고 TCCR0 레지스터의 3번(WGM01)과 6번(WGM00) 비트를 사용해서 어떤 모드로 동작할 지 선택한다. <br>
(3,6)이 00일때 노말모드, 01일때 PWM,page correct, 10일때 CTC 모드, 11일때 fast PWM 모드로 동작한다. <br>

### normal mode :  기본 동작방식
클락을 세는 레지스터(TCNT0, 8비트)가 끝까지(255까지) 갔다가 0으로 돌아오고 다시 끝까지 간다. <br>
0,1,2,3,4,...,255,0,1.... <br>
이 과정을 반복하면서 클락을 세는게 노말방식. 255에서 0으로 넘어갈때 마이크로프로세서에게 TOV인터럽트를 걸어 알려준다. <br>
이 인터럽트를 enable 시키는 것은 TIMSK 레지스터의 0번째 비트(TOIE0)다. 이 비트가 1이어야 인터럽트가 걸린다.<br>
다만 이 256클락이라는게 너무 짧아서 사람이 인지할 수 없기 때문에 확인을 위한 방법이 존재한다. <br>
소프트웨어적으로 코딩을 하거나, 하드웨어적으로 클락을 느리게 하면 된다. <br>
TCCR0 레지스터(8비트) : 클락 조절하는 레지스터. 0,1,2 자리 비트(cs00 , cs01, cs02 cs는 clock selection의 약자)에 0또는 1을 넣어 설정 <br>
000이면 clock가 0인경우. 즉 타이머가 동작하지 않는다. <br>
001은 clkt0s , 기존 클락이 들어간다. <br>
010은 기존클락 나누기 8. 즉 8배 느린 클락이 들어간다. 원래가 800이면 100클락. 클락의 길이가 길어짐(원래 8클락짜리 길이를 가지는 1클락). <br>
011은 기존클락 나누기 32 <br>
이런식으로 64,128,256,1024까지 8가지 종류로 나눌 수 있다. <br>
이렇게 클락을 인위적으로 느리게 만드는 방법을 pre-scale이라고 부른다. <br>
<br>
다만 이런식으로 클락을 측정하는건 위에 보다시피 종류가 제한적이기 때문에 이를 해결하는 방법이 있다. <br>
첫 번째는 TCNT0 값을 바꾸기. 0부터 255까지 증가하며 클락을 세는 이 레지스터의 값을 인위적으로 바꾸는 것이다. <br>
TCNT0 = 0; <br>
위에 처럼 지정해주면 클락을 0부터 세지 않고 100부터 시작해서 255까지 156개를 센다. 이렇게 인위적인 조절을 한다. <br>
<br>
첫 번째 방법은 딱히 좋지 않다. 계속 바뀌는 값을 중간에 인위적으로 바꾸는 건 상당히 위험한 일이다.<br>
그래서 두 번째 방법이 노말모드 말고 다른 모드를 쓰는 것이다.
<br>

### Clear Timer on Compare Match(CTC) 모드
내가 정한 값까지 클락을 세고 0으로 돌아가는 모드. 타이머의 세밀한 조작이 가능해진다.<br>
내가 임의로 정한 값은 OCR0레지스터에 저장된다. 즉 OCR0 = 199; 라고 하면 0부터 199까지 세고 0으로 돌아가게 동작한다. <br>
0으로 돌아갈 때 걸리는 인터럽트는 OCF 인터럽트라고 부른다. <br>
이 인터럽트를 enable 시키는 것은 TIMSK 레지스터의 1번째 비트(OCIE0)다. 이 비트가 1이어야 인터럽트가 걸린다.<br>
<br>
또한 인터럽트가 발생한 사실을 기억하는 레지스터도 있다. TIFR 레지스터다. 위에 외부 인터럽트 내용에서 엣지가 발생한 사실을 기억하는 EIFR이라는 레지스터와 비슷한 역할이다.<br>
TIFR 레지스터의 0번째비트(TOV0) 1번째비트(OCF0)가 이런 사실을 기록한다. OCF 인터럽트의 경우 OCF0비트가 1로 바뀐다. <br>
그리고 이 1로 바뀐 비트는 해당 인터럽트가 걸려서 ISR으로 가는 순간 0으로 바뀐다. <br>
<br>
#### OC(output compare) pin
PB4번핀만 가능한 기능 <br>
타이머가 특정값(OCR)이 도달했을 때 값이 1로 바뀌고 다음번엔 0 그 다음은 1로 바뀐다.<br>

노말모드에서 나왔던 TCCR레지스터에는 4번(com00)비트와 5번비트(com01)가 있는데 (4,5)순서로 (0,0)이면 노말포트(일반적인 GPIO모드), (0,1)은 toggle(0이면 1로 1이면 0으로 바꾸는것), 나머지는 잘 쓰지 않음. 주로 토글로 사용. <br>

### 0번 타이머


## 마이크로프로세서 간의 통신
제어신호 : 누구에게, 언제 보낼것이지를 알리는 신호
parallel :병렬 통신, 데이터 여러비트가 동시에 가는 방식. IDE 케이블.
serial : 직렬통신, 시간으로 나눠서 차례대로 보내는 방식. 구현이 간단. SATA 케이블. 병렬보다 느렷지만 이제는 더 빨라짐.

### UART(universal asynchronous receiver & transmitter)
많은 마이크로프로세서에서 채택하고있는 통신방식. RS-232라고도 부름. <br>
시리얼 통신방식. 데이터 핀이 하나만 존재. 제어핀이 따로 없다. 수신기와 송신기가 딱 하나의 핀으로만 연결.<br>
1. 통신을 안하고 있는 평상시에는 송신기가 수신기와 연결된 핀으로 5V를 계속 내보내고 있음. <br>
2. 통신을 시작하려면 해당 핀으로 전압을 0V로 내림.(start bit) <br>
3. LSB부터 1비트씩 전송. <br>
4. 미리 약속된 비트수만큼 전송이 끝나면 5V(stop bit)로 다시 전송. <br>
<br>
Atmega128의 송신기에는 송신할 데이터를 저장해둘 UDR이라는 레지스터가 있다. <br>
송신시작은 UDR 레지스터에 write하면 송신이 시작됨. <br>
송신핀은 TXD라고 부름. PE1핀을 사용. <br>
수신핀은 RXD라고 부름. PE0핀을 사용 <br>
수신한 데이터를 저장하는 레지스터도 UDR이다. <br>
TXEN(UCSRnB 레지스터의 3번비트): 1로 설정하면 송신가능하게(PE1핀을 TXD로 쓰겠다.) <br>
RXEN(UCSRnB 레지스터의 4번비트): 1로 설정하면 수신가능하게(PE0핀을 RXD로 쓰겠다.) <br>
UCSZ(UCSRnB 레지스터의 2번비트, UCSRnC 레지스터의 2번 1번비트): 주고받을 데이터가 몇 비트인지 지정  <br>
UCSZ 필드의 3개 비트들을 000 : 5~6비트, 001 : 6비트, 010 : 7비트, 011 : 8비트 등등으로 설정해서 사용 <br>
<br>
UBRR 레지스터 : UART Baud Rate Register, 12비트. 전송률을 결정하는 레지스터, 1초에 데이터를 얼마나 전송하는가. <br>
1개의 비트 전송에 시간을 얼마나 할애하는가. 시간을 늘리면 데이터가 줄고 시간을 줄이면 데이터량이 늘어난다. 이 시간을 조절하는 레지스터 <br>
이 레지스터의 값이 커질수록 데이터 전송률은 줄어든다. <br>

송신기에서 데이터를 다 송신했음을 나타내는 비트  : TXC(UCSRnA레지스터의 6번비트) 1로 설정되면 송신이 끝났음 & UDR이 비었음을 의미. <br>
TXCIE : 1로 해두면 TXC가 1일 때 인터럽트가 걸린다. <br>
TXCIE 인터럽트가 걸리면 TXC가 0으로 초기화됨. 혹은 1적어주면 0으로 초기화됨. <br>
<br>
송신기에는 UDRE 비트(UCSRnA레지스터의 5번비트)도 있는데, UDR(송신할 데이터를 저장하는곳)이 비었을 때 1로 셋팅된다. UDR에 데이터를 write할때 0으로 초기화된다.<br>
위와 마찬가지로 UDRIE 인터럽트가 있다. <br>
<br>
UDR 레지스터에 저장된 송신할 데이터는 바로 나가는 게 아니라 shift 레지스터에 옮겨졌다가 나간다. 따라서 TXC보다 UDRE가 먼저 1로 셋팅된다. <br>
<br>

### Parity & Error Check
Error : 데이터가 중간에 사라지거나 다른 값으로 바뀌는 것 <br>
Error Check의 대표적인 방식 : Parity Check <br>
10101110 이라는 데이터를 보낼 때 데이터를 앞에서부터 바로 뒤에꺼랑 xor 시키고 결과를 이어서 뒤에 비트들과 xor 시킨 최종 비트를 데이터 뒤에 함께 보냄. xor의 결과는 1001011 마지막에 나온 1을 Parity 비트로 붙여서 함께 전송. <br>
따라서 송신측은 101011101을 보내고, 수신측은 받은 데이터를 똑같이 앞에서 부터 Parity를 계산한다. 1001011을 구했으면 마지막 비트를 Parity랑 비교해본다. 다르다면 비정상. <br>
Parity가 손상된다면? 중간에 데이터가 손상됐는데 Parity랑 같은게 나온다면? <br>

UPM필드(UCSRnC레지스터의 4,5번 비트) : 송수신 양측이 같은 셋팅이어야 함. 값의 의미는 <br>
00 : disabled(Parity 안보냄), <br>
01 : reserved, <br>
10 : enabled even(위에처럼 다 xor 시키는거), <br>
11 : enabled odd(다 xor 시키고 마지막에 뒤집는거) <br>
<br>
수신측은 잘못된 비트들을 받았을 때 다음과 같은 방법으로 오류를 알린다. <br>
UPE(UCSRnA 레지스터의 2번 비트) : 현재 UDR에 들어있는 데이터가 에러가 있을 때 1로 셋팅. 에러가 없으면 0으로 셋팅. Parity error를 단순히 알리는 용도. <br>

#### FE, Frame Error
UCSRnA 4번 비트 <br>
Stop bit은 5V여야 하는데 0V인것. 송수신측이 데이터 전송률이 서로 다른경우에 발생. <br>

#### DOR, Data OverRun
UCSRnA 3번 비트 <br>
UDR을 천천히 읽어서 수신된 데이터가 유실된 것. 바로 안읽어서 방치된 데이터가 있을 때 새로 들어온 데이터에 의해 덮어씌워지는 경우. 혹은 새로 들어온 데이터가 버려지는 경우. 이때 이 비트가 1이되서 문제가 있음을 알림.<br>
<br>
<br>
위에서 나온 3가지 오류를 항상 미리 체크하고 오류가 없을 때 UDR을 읽어야 한다. 


## ADC Analog to Digital Converter
아날로그 형태로 받은 전압을 디지털 값으로 바꾸는 장치. <br>
변환 범위 : 0V ~ Vcc(최고 전압값) / 0V ~ Vref(Vref핀으로 들어오는 전압값) / 0V ~ 2.56V <br>
구간 갯수 : 10 bit resolution : 1024개 구간으로 나눔. <br>
동작 타이밍(얼마나 자주) : 1. single conversion(한 번 변환하고 멈춤) 2. free running(시작해두면 알아서 계속 변환) <br>

ADC = (Vin/Vref) * 1024 <br>


1차 질문 <br>
요즘 C나 c++로 코딩을 한다는데 우리가 하는거는 언어가 뭐지 : 실제로 할 때는 C언어 아트맬스튜디오 로우레벨은 과제에서 안다루고..<br>
메모리(RAM일까) 위치. 크기. : 내부메모리 d램 32kb 프로그램이 들어가는. , 캐쉬..<br>
IR(instruction register)와 그냥 레지스터의 차이 : 컴퓨터구조 설계. RISC CISC 차이점.<br>
ADC : ADD를 꼭 더하기에만 쓰는 건 아니니까.<br>

2차 질문
전압 0,5만 잇는데 더 늘리기 가능? : 이건 바이너리 시스템이라 쓰는 거니까 근본을 갈아엎어야하니 불가. <br>
블루투스 등 무선 신호를 어디서 어떤식으로 바꿔주는가 : 모듈을 사용 <br>
값싼 칩에 모듈 추가하는거랑 애초에 비싼 칩을 쓰는경우 뭐가 더 경제적으로 이득인가? : 상업적으로 비싼 칩을 더 선호하긴 하는데 케바케 <br> 
다른 무선 신호 잡음을 구분하는 프로토콜이 올라갈 공간이 없는데 어떻게 구분하는가  : 모듈에서 처리 <br>

3차질문
SREG가 1일때 enable로 설정된 인터럽트들만 받아들인다는데 0인경우 스위치가 열린다면 모든 인터럽트가 무시되는 것이 아닌가? <br>
레벨트리거는 전압튀어도 일정시간 유지가 안되니까 무시하는데, 엣지 트리거 방식일때 전압이 튀면 이건 인식을 하는가? <br>
엣지 트리거 방식일때 EIFR의 비트를 0으로 만들때 1을 써준다? 회로의 동작원리<br>
clock이 0과 1이 교차로 들어오는 신호인데 전압 튀는건 ㄱㅊ?<br>
