## AVR
8비트 마이크로프로세서. 32개 8비트 레지스터 내장. <br>
LDI R0,2 : 레지스터 R0에 2 저장 <br>
ADD R0,R1 : 레지스터 R0과 R1의 값을 더해서 R0에 저장 <br>
SUB R0,R1 : 레지스터 R0의 값에서 R1의 값을 빼서 R0에 저장 <br>
INC R0 : 레지스터 R0값을 1 증가.<br>

### 분기명령어

CP R0,R1 : 둘 값을 비교 <br>
CPI R0, 4 : 상수와 비교하는 경우 <br>
BRGE 1 : R0이 R1보다 크거나 같은 경우 1줄 건너뛰고 실행 <br>
BRLT 1 : R0이 R1보다 작은 경우 1줄 건너뛰고 실행 <br>
BREQ 1 : R0이 R1과 같은 경우 1줄 건너뛰고 실행 <br>
BRNE 1 : R0이 R1과 다른 경우 1줄 건너뛰고 실행 <br>
RJMP -2 : 바로 위 문장으로 점프 <br>
<br>

### 메모리 명령어
레지스터가 방안의 책장이라면 메모리는 도서관이다. 마이크로프로세서 밖에 위치해서 저장공간은 많지만 왓다갔다 시간이 오래걸린다. <br>
그래서 메모리에 있는 값을 가져와서 레지스터에 임시저장(Load)하고 연산을 한 뒤 결과를 메모리로 저장(Store)하는 과정을 거친다.<br>
메모리에도 공간마다 주소라고 부르는 번호가 있다.<br>
메모리에 값을 바로 때려박을 수는 없고 레지스터에서 불러오는 식으로 저장을 해야한다.<br>
그러니까 메모리 100번지에 3을 넣고 싶으면 LDI R0,3 이렇게 R0레지스터에 3을 박고, <br> 
STS 100, R0 이렇게 100번지 메모리에 레지스터 R0의 값을 저장하는 식이다. <br>
<br>
메모리에 저장된 값을 불러오려면 LDS R0,100으로 100번지에 저장된 값을 레지스터 R0에 불러온다.<br>
<br>

### 레지스터 묶기
레지스터에 값을 저장하려는데 값이 257이다.<br>
이러면 8비트 레지스터 하나에 저장할 수 없으니까 레지스터 2개(R0,R1)를 묶는다.<br>
그러면 ( 0000 0001 )( 0000 0001) 로 저장이 된다. <br>
즉 실제로 저장된 값은 R0과 R1 모두 1이지만 257로 취급한다. <br>
따라서 LDI R0,1      LDI R1,1 이다. <br>
515는  ( 0000 0010 )( 0000 0011) 이런식으로     LDI R3,2     LDI R2,3   이렇게 한다. <br>
두 경우 모두 R1, R3이 상위바이트, 나머지가 하위바이트라고 한다.<br>
<br>
자 그럼 이 두 값 257과 515를 덧셈을 하려면 어떻게 할까.<br>
간단하게는 상위바이트는 상위바이트끼리 하위바이트는 하위바이트끼리 더하면 된다.<br>
즉 ADD R2,R0과 ADD R3, R1을 하면 된다.<br>
하지만 257과 511같은 경우 ( 0000 0001 )( 0000 0001)과 ( 0000 0001 )( 1111 1111)이므로 R0에 FF가 저장된다. <br>
이 상태로 단순히 하위 바이트들끼리 덧셈을 하면 (0000 0000)이 되면서 R2에 00이 들어가버린다. <br>
따라서 이 오버플로우로 생기는 carry값을 어딘가에 저장을 하고 이용해야 한다. <br>
다만 캐리값 저장은 마이크로프로세서가 알아서 해주니까 이용만 잘 하면 된다.<br>
이용하는 방법은 바이트끼리 짝지어 덧셈을 할때 ADD가 아닌 ADC를 사용하는 것이다. <br>
뺄셈의 경우는 SBC를 사용.<br>

### 기계어
ADD R3,R2라고 코딩을 하더라도 이걸 기계가 알아먹을수는 없다. AVR이라는건 결국 논리회로 덩어리기계이므로 0과 1로 바꿔져서 AVR로 들어가게 된다. <br>
이 바뀌는 규칙이 있는데 ADD Rd,Rr을 기계어로 바꾸려면 다음과 같은 규칙을 따른다.<br>
#### 0000 11rd dddd rrrr
이대로 ADD R3, R2를 바꿔보면 <br>
R3은 다섯비트로 00011, R2는 00010이니까 이게 각각 ddddd, rrrrr이다.<br>
따라서 0000 1100 0011 0010이라는 기계어가 실제로 AVR에 들어간다. <br>
표현할때는 간단하게 16진수로 0C32 <br>
<br>
LDI Rd, k(상수)를 기계어로 바꾸는 규칙은 아래와 같다.<br>
#### 1110 kkkk dddd kkkk
여기서 그런데 d를 보면 비트가 4개다. 그럼 표현할 수 있는 가짓수는 16개. 그런데 레지스터는 32개다. <br>
그래서 조건이 붙는다. 이때 레지스터는 16번이상 31번 이하다. R0은 못온다는 이야기.<br>
16번 이상이라는 말은 2진수로 바꿨을때 가장 큰 자릿수가 무조건 1이니까, 그 1은 제외하고 뒤 4자리를 dddd로 사용하면 된다.<br>
또한 상수값은 8개 비트로 사용되므로 0이상 255이하만 k가 될 수 있다.<br>
저 위에서 했던 예시들은 다 문법에 맞지않는다(...)<br>
그래서 올바른 예시로 LDI R17, 5를 바꿔보면 <br>
17은 10001이므로 0001이 dddd, 5는 0000 0101로 kkkk kkkk자리에 넣어서 <br>
1110 0000 0001 0101 이 실제 AVR로 들어가는 기계어다. <br>
16진수로는 E015.<br>
<br>
BRGE K 규칙은<br>
#### 1111 01kk kkkk k100
BRGE 1은 1111 0100 0000 1100이다. (F40C) <br>
<br>
<br>
다만 이런 과정은 모두 어셈블러가 대신 해주기때문에 직접 할 필요는 없다. <br>
<br>
이 기계어는 마이크로프로세서의 메모리로 올라간다.(이 메모리는 내장?) <br>
마이크로프로세서는 메모리에 있는 코드를 가져오고 해석한뒤 실행한다. <br>
그리고 그 다음번지에 저장된 코드를 가져와서 해석하고 실행하는 동작을 계속한다.<br>
이렇게 동작하기 위해서는 마이크로프로세서가 자신이 어디까지 읽었는지 기억하고 있어야 다음에 읽을 코드위치를 알 수 있다.<br>
이렇게 다음으로 실행할 코드가 어딨는지 알려주는게 마이크로프로세서 내부에 있는 PC(program counter)이다. <br>
PC의 초기값은 0이고, 이 값을 주소로 삼아서 읽어오는 것이다. <br>
읽어서 실행하고 나면 PC값을 하나 증가시키는 과정을 반복한다. <br>
<br>
그런데 PC가 항상 1씩 증가하는건 아니다. <br>
분기명령을 만났을 때는 감소할 수도 증가할 수도 있다. <br>
<br>
예를 들어 BRGE 1의 경우에 PC값은 조건에 맞으면 PC + k + 1 이고, 조건에 맞지 않으면 PC + 1이다.<br>
즉 조건에 맞지 않으면 그냥 원래대로 1증가 하는거고, 조건에 맞다면 BRGE 뒤에 붙은 k에 따라 달라지는 것이다. <br>

### ISA(instruction Set architecture) 명령어 집합 구조
instruction set + memory structure + resgister set <br>
이점 : 소프트웨어 개발자가 내부구조에 대해 알 필요가 없다. , 하드웨어 개발자는 어떤 소프트웨어를 만들든 명령어 집합 구조만 만족시키면 된다. 인텔프로세서처럼 하위버전과 같은 구조라면 프로그램이 그대로 구동가능하다. <br>
instruction register : 프로그램 메모리에서 읽어온 명령어를 실행하기 위해 저장하는 곳(16비트 공간) <br>
IR이 MUX(멀티플랙서, 모든레지스터의 한개 비트와 연결)와 연결되어 어떤 레지스터가 연결될지를 제어한다.<br>
<br>
### 크기비교
크기비교(CP)의 결과는 SREG(special 레지스터, 8비트ITHSVNZC)라는 레지스터 내부의 VNZC에 저장됨.<br>
크기 비교는 기본적으로 비교할 두 값을 빼서 판단한다. <br>
a-b를 했을때 음수면 a가 작은 것이므로 N(Negative) 비트 부분이 1로 표시 Z(Zero)는 같음을 나타내는 것이므로 0으로 표시 <br> 
<br>
V는 overflow를 나타내는데 결과가 8비트를 넘은 경우다. <br>
a가 127이고 b가 -2라면 a가 b보다 큰건데 두개를 빼면 0111 1111 - 1111 1110이니까 덧셈으로 바꿔서 0111 1111 + 0000 0001에 뒤에 캐리 1추가. <br>
계산하면 1000 0001이 나온다. <br>
제일 앞에 비트가 1이니까 음수로 처리된다. 그래서 -127로 해석되서 N비트가 1로 셋팅이 된다. <br>
8비트로 표현할 수 있는 수는 -128부터 127까지인데 결과가 129니까 엉뚱한 수인 -127이 나온것이다. <br>
이럴 때를 대비해서 V비트가 있다. <br>
위의 경우에 N비트와 V비트가 1이 되서 단순히 N만 보고 판단하지 않고 V와 함께 판단한다. <br>

## GPIO control
General purpose input output. 목적이 정해지지 않고 일반적인 목적(범용, 다목적) 입출력.<br>
마이크로프로세서는 핀을 통해 입출력을 한다. <br>
입력은 전압에 따라 동작하는 것이고, 출력은 이 전압을 유지시키는 것이다. <br>
drive한다. : 전압을 바꿀 수 있다. <br>
1개의 핀으로 1비트의 정보를 전달할 수 있다. <br>
ATmega128은 64개의 핀이 있다. <br>
핀들은 전력핀과 신호핀으로 분류할 수 있다.
전력핀은 전원을 공급해주는데 총 6개가 있고 5V(VDD VCC) 0V(기준전압,VSS GND) 등으로 표기되어있다. <br>
나머지는 신호핀인데 신호핀은 특수목적핀과 다목적핀으로 구분된다. <br>
특수목적핀은 총 5개로 하드웨어적으로 목적이 고정되어 있다. 예를 들면 오직 리셋 기능만 하는 리셋핀이 있다.<br>
다목적핀은 나머지 53개로 사용자가 원하는 목적대로 제어를 할 수 있다. <br>
<br>
다목적핀을 어떻게 다룰 것인가.<br>
53개를 동시에 쓸 수는 없고 AVR은 8비트 단위로 움직이므로 8비트 그룹이 필요하다. <br>
A~G그룹이 존재한다. PA0 ~ PA7, ... , PG0 ~ PG7 까지<br>
고려사항 첫번째는 방향설정(입력인가 출력인가), 방향을 정했다면 출력의 경우엔 출력값을 지정해줘야 한다. 입력의 경우에는 입력값을 읽어올 수 있어야한다. <br>
<br>
#### 방향설정
방향설정에는 레지스터가 필요하다. 입력인지 출력인지를 정했으면 그걸 저장해야 하기 떄문이다. 핀 묶음이 8개이므로 8비트짜리 레지스터에 다 저장가능하다. 이때 사용하는 레지스터가 DDR 레지스터인데 PA의 경우 DDRA를 사용해서 정보를 저장한다. PB핀은 DDRB레지스터 이런 식이다.  저장 방식은 DDRA의 경우 0번 비트가 PA0 핀의 방향을 저장하는데, 입력으로 사용하는 경우 0, 출력으로 사용하는 경우 1로 셋팅된다. <br>
<br>
그럼 이 DDRA라는 레지스터에 값을 어떻게 저장해야할까 <br>
memory mapped I/O. <br>
AVR의 메모리 주소는 16비트다. 16비트로 표현할 수 있는 가짓수는 65535개. 0x0000부터 0xffff까지.<br>
재밌는건 0x0000은 R0의 주소다. 레지스터들에 주소가 할당이 되어있어서 비효율적이지만 이 주소를 사용하여 레지스터에 값을 넣을 수도 있다. <br>
메모리중에는 이런 레지스터들을 위해 할당된 공간도 있다.<br>
LDI R16, 3 <br>
STS 0x003A , R16 이라고 하면 <br>
해당 주소가 가리키는 DDRA 레지스터에 00000011이 저장된다. <br>
c언어 코드 : *((char *) OxOO3A) = 3 <br>
<br>*
#### 출력값 지정
8비트 레지스터인 PORTA를 이용한다. 이 레지스터의 주소는 0x003B다. <br>
이 레지스터의 각 비트의 값은 PA0 ~ PA7의 출력되는 값이다. <br>
0이면 0V, 1이면 5V가 나간다는 말이다. <br>
LDI R16, OxFF <br>
STS 0x003A , R16  // PA 모두 출력으로 사용하겠다.<br>
LDI R16, Ox36 <br>
STS 0x003B , R16 <br>
이렇게 하면 PORTA 레지스터에 0011 0110이 저장된다. <br>
차례대로 PA7은 0볼트, ... , PA1 5볼트, PA0은 0볼트가 출력값으로 지정된다.  <br>
<br>
#### 입력값 읽어오기
뭘 읽어올지 지정을 해야한다. <br>
0x0039 번지의 PINA 레지스터가 있다. <br>
LDS R16, 0x0039를 하면 이 주소에 해당하는 PINA, 즉 PA0부터 PA7까지 들어오고있는 입력값을 읽어서 R16에 저장한다. <br>
입력값이 0V 이면 0으로, 5V라면 1로 저장한다. <br>
<br>

## 인터럽트
하던 작업을 멈추고 이 작업(ISR, interrupt service routine)을 해달라고 하드웨어적으로 요청하는 것.<br>
인터럽트 발생원으로는 reset, timer, INT 등등 50가지가 넘게 있다. <br>
ISR 위치는 프로그램 메모리의 정해진 위치에 들어간다. INT0의 경우 0002번지에 해야할 일이 있고, TIMER 1 CAPT는 0016번지에 작업이 있다.<br>
mask enable/disable 은 다양한 인터럽트에 대한 반응을 결정한다. 즉 프로그래머가 특정 인터럽트를 무시하려면 mask나 disable로 하면 된다. <br>
인터럽트를 처리하겠다 하면 enable이라고 한다. 이런 과정은 각 인터럽트마다 정해진 레지스터에 값을 셋팅함으로써 결정할수있다.<br>
<br>

### Global interrupt enable
모든 인터럽트에 대해 작업을 받을지 안받을지를 한꺼번에 지정하는 기능이 있다. 위에서 나온 SREG의 최상위 비트인 I를 0으로 하면 어떤 인터럽트든 무시하고, 1이면 인터럽트들 중에 enable로 설정된 인터럽트만 받아들인다.<br>
<br>

### external interrupt 외부 인터럽트


요즘 C나 c++로 코딩을 한다는데 우리가 하는거는 언어가 뭐지 : 실제로 할 때는 C언어 아트맬스튜디오 로우레벨은 과제에서 안다루고..<br>
메모리(RAM일까) 위치. 크기. : 내부메모리 d램 32kb 프로그램이 들어가는. , 캐쉬..<br>
IR(instruction register)와 그냥 레지스터의 차이 : 컴퓨터구조 설계. RISC CISC 차이점.<br>
ADC : ADD를 꼭 더하기에만 쓰는 건 아니니까.<br>
심전도 측정과 전송과정 : <br>




